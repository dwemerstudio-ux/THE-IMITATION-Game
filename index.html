<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>Игра в Имитацию: Кто же ты?</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* БАЗА КОР */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: radial-gradient(circle at top, #1a2a3a 0, #05070b 55%, #000000 100%);
      background-size: 200% 200%;
      animation: bg-shift 28s ease-in-out infinite alternate;
      color: #00ff9c;
      font-family: "Courier New", monospace;
      font-size: 15px;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      position: relative;
      overflow-x: hidden;
      overflow-y: auto;
    }

    body.theme-default {
      filter: none;
    }

    body.theme-violet {
      filter: hue-rotate(60deg) saturate(1.05);
    }

    body.theme-amber {
      filter: saturate(0.8) brightness(0.9);
    }

    body.theme-amber .bg-lines,
    body.theme-amber .bg-orbit {
      opacity: 0.18;
    }

    body.theme-amber #game-root {
      border-color: #e0b36a;
      background: rgba(12, 9, 4, 0.96);
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.9);
      animation: none;
    }

    body.theme-amber #logo {
      color: #f5d7a3;
      text-shadow: none;
      animation: none;
    }

    body.theme-amber .choice-btn {
      border-color: #e0b36a88;
      background:
        linear-gradient(135deg, rgba(24, 17, 6, 0.96), rgba(16, 10, 2, 0.96));
    }

    body.theme-amber .choice-btn:hover {
      box-shadow: 0 0 6px #000000aa;
      border-color: #f5d7a3cc;
    }

    body.theme-amber #alignment-fill-human {
      background: linear-gradient(90deg, #f5d7a3, transparent);
    }

    body.theme-amber #alignment-fill-tech {
      background: linear-gradient(270deg, #c9a86a, transparent);
    }

    body.theme-amber #theme-box {
      color: #e0c197;
    }

    body.theme-amber .theme-chip {
      border-color: #b4935a55;
      color: #f5d7a3dd;
    }

    body.theme-amber .theme-chip.active {
      box-shadow: none;
    }

    body.theme-amber #ai-comment {
      color: #f0d19b88;
      text-shadow: 0 0 3px #000;
    }

    @keyframes bg-shift {
      0% { background-position: 0% 0%; }
      100% { background-position: 100% 100%; }
    }

    .bg-lines {
      position: fixed;
      inset: -20px;
      background-image:
        linear-gradient(
          rgba(0, 255, 156, 0.08) 1px,
          transparent 1px
        ),
        linear-gradient(
          90deg,
          rgba(0, 255, 156, 0.08) 1px,
          transparent 1px
        );
      background-size: 40px 40px, 40px 40px;
      opacity: 0.15;
      pointer-events: none;
      z-index: 0;
      mix-blend-mode: screen;
      animation: grid-move 20s linear infinite;
    }

    @keyframes grid-move {
      0% { transform: translate3d(0, 0, 0); }
      100% { transform: translate3d(-40px, -40px, 0); }
    }

    .bg-orbit {
      position: fixed;
      border-radius: 50%;
      border: 1px dashed rgba(0, 255, 156, 0.3);
      box-shadow: 0 0 16px rgba(0, 255, 156, 0.2);
      pointer-events: none;
      z-index: 0;
    }

    .orbit-1 {
      width: 60vw;
      height: 60vw;
      top: -20vw;
      right: -10vw;
      animation: orbit-spin 42s linear infinite;
    }

    .orbit-2 {
      width: 40vw;
      height: 40vw;
      bottom: -15vw;
      left: -5vw;
      animation: orbit-spin 55s linear infinite reverse;
    }

    .orbit-3 {
      width: 30vw;
      height: 30vw;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      animation: orbit-pulse 30s ease-in-out infinite;
      opacity: 0.2;
    }

    @keyframes orbit-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes orbit-pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.1); }
    }

    .edge-glitch {
      position: fixed;
      top: 0;
      bottom: 0;
      width: 22px;
      pointer-events: none;
      z-index: 3;
      opacity: 0;
      mix-blend-mode: screen;
      background:
        linear-gradient(
          to bottom,
          rgba(0, 255, 156, 0) 0%,
          rgba(0, 255, 156, 0.4) 30%,
          rgba(255, 0, 255, 0.4) 60%,
          rgba(0, 255, 156, 0) 100%
        );
      transform: translateZ(0);
    }

    .edge-glitch-left { left: 0; }
    .edge-glitch-right { right: 0; }

    body.glitch-strong .edge-glitch {
      opacity: 0.45;
      animation: edge-glitch-flicker 0.3s steps(2, start) infinite;
    }

    @keyframes edge-glitch-flicker {
      0% { transform: translateX(0); filter: hue-rotate(0deg); }
      50% { transform: translateX(2px); filter: hue-rotate(30deg); }
      100% { transform: translateX(-1px); filter: hue-rotate(-20deg); }
    }

    #transition-rift {
      position: fixed;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      transform: scale(1);
      z-index: 1000;
      background:
        radial-gradient(circle at 50% 50%, rgba(255,255,255,0.18) 0, rgba(255,255,255,0.08) 20%, transparent 45%),
        repeating-linear-gradient(
          135deg,
          rgba(0,255,156,0.0),
          rgba(0,255,156,0.0) 6px,
          rgba(0,255,156,0.3) 8px,
          rgba(255,0,193,0.3) 10px,
          rgba(0,0,0,0.0) 12px
        );
      mix-blend-mode: screen;
      background-size: 160% 160%;
    }

    #transition-rift.show {
      animation: rift-open 0.9s ease-in-out forwards;
    }

    @keyframes rift-open {
      0%   { opacity: 0; transform: scale(0.9); }
      25%  { opacity: 0.9; transform: scale(1.02) rotate(2deg); }
      60%  { opacity: 0.6; transform: scale(0.98) rotate(-2deg); }
      100% { opacity: 0; transform: scale(1) rotate(0deg); }
    }

    .crt {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background:
        repeating-linear-gradient(
          rgba(0, 0, 0, 0.18),
          rgba(0, 0, 0, 0.18) 1px,
          rgba(0, 0, 0, 0.22) 2px
        );
      mix-blend-mode: multiply;
      opacity: 0.6;
      z-index: 5;
    }

    /* === ВЕРСТКА ИНТЕРФЕЙСА (обновлено масштабирование) === */
    #game-root {
      position: relative;
      max-width: 1100px; /* было 960 — расширили примерно на 15% */
      width: 100%;
      background: rgba(3, 8, 16, 0.94);
      border: 2px solid #00ff9c;
      box-shadow: 0 0 18px #00ff9c55;
      padding: 20px;
      overflow: hidden;
      z-index: 2;
      backdrop-filter: blur(2px);
    }

    #header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #00ff9c55;
      padding-bottom: 8px;
      margin-bottom: 8px;
      font-size: 13px;
    }

    #logo {
      font-weight: bold;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #7cfbff;
      text-shadow: 0 0 6px #00ff9caa;
      animation: logo-glow 3.5s ease-in-out infinite;
    }

    @keyframes logo-glow {
      0%, 100% { text-shadow: 0 0 4px #00ff9caa; }
      50% { text-shadow: 0 0 12px #7cfbffaa; }
    }

    #header-right {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    #role-display {
      font-style: italic;
      color: #00ff9c;
      font-size: 12px;
      opacity: 0.9;
    }

    .icon-btn {
      border: 1px solid #00ff9c66;
      background: rgba(0, 0, 0, 0.7);
      color: #00ff9c;
      border-radius: 4px;
      font-size: 11px;
      padding: 3px 6px;
      cursor: pointer;
      box-shadow: 0 0 6px #00ff9c55;
      transition: background 0.15s, transform 0.07s, color 0.15s;
    }

    .icon-btn:hover {
      background: rgba(0, 255, 156, 0.18);
      box-shadow: 0 0 8px #00ff9c77;
      transform: translateY(-1px);
    }

    .icon-btn:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    .icon-btn.on {
      color: #07130f;
      background: #00ff9c;
      box-shadow: 0 0 12px #00ff9caa;
    }

    #achievements-strip {
      display: flex;
      align-items: center;
      gap: 3px;
      margin-right: 4px;
    }

    .ach-icon {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid #00ff9c33;
      font-size: 9px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.25;
      color: #00ff9c55;
      background: rgba(0, 0, 0, 0.5);
      cursor: default;
      box-shadow: none;
      transition: opacity 0.2s, border-color 0.2s, box-shadow 0.2s, transform 0.1s;
    }

    .ach-icon.unlocked {
      opacity: 1;
      color: #000;
      border-color: #7cfbffcc;
      background: radial-gradient(circle at 30% 20%, #ffffff, #00ff9c);
      box-shadow: 0 0 6px #00ff9c77;
      transform: translateY(-1px);
    }

    .ach-icon.unlocked:hover {
      box-shadow: 0 0 10px #7cfbff99;
    }

    /* === ГРИД ИГРОВОГО ПОЛЯ === */
    #screen {
      display: grid;
      grid-template-columns: minmax(0, 1.2fr) minmax(0, 1fr);
      gap: 14px;
      margin-top: 4px;
    }

    @media (max-width: 720px) {
      #screen {
        grid-template-columns: 1fr;
      }

      #role-display {
        font-size: 11px;
      }

      #achievements-strip {
        display: none;
      }
    }

    /* === КАРТИНКА: крупнее, с min-height 600 === */
    #image-box {
      border: 1px solid #00ff9c55;
      background: radial-gradient(circle, #041018 0, #020509 70%);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;

      min-height: 600px; /* твой фикс, чтобы картинка была крупнее */
    }

    #image-box::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(
        120deg,
        transparent 0,
        rgba(0, 255, 156, 0.04) 40%,
        transparent 80%
      );
      mix-blend-mode: screen;
      pointer-events: none;
    }

    #image-box img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      filter: saturate(1.15) contrast(1.1);
      transform: scale(1.02);
      opacity: 0;
      transition: opacity 0.4s ease-out;
    }

    #image-box img.show {
      opacity: 1;
    }

    #image-box .placeholder {
      font-size: 12px;
      color: #00ff9caa;
      text-align: center;
      padding: 8px;
    }

    /* === ПРАВАЯ ЧАСТЬ: ТЕКСТ + ВАРИАНТЫ === */
    #scene-box {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    #scene-title {
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #7cfbff;
      font-size: 14px;
    }

    #scene-text {
      font-size: 15px;
      line-height: 1.5;
      white-space: pre-wrap;
      margin-top: 2px;
    }

    #choices {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: stretch;
    }

    /* Карточки выбора */
    .choice-btn {
      --card-rot: 0deg;
      background: linear-gradient(
        135deg,
        rgba(0, 0, 0, 0.9),
        rgba(0, 40, 30, 0.95)
      );
      border: 1px solid #00ff9caa;
      color: #00ff9c;
      padding: 8px 10px;
      text-align: left;
      font-size: 15px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      border-radius: 8px;
      transform: translateY(0) rotate(var(--card-rot));
      transition:
        background 0.15s,
        transform 0.07s,
        box-shadow 0.15s,
        border-color 0.15s;
    }

    .choice-btn::before {
      content: ">";
      margin-right: 6px;
      color: #7cfbff;
    }

    .choice-btn:hover {
      background: linear-gradient(
        135deg,
        rgba(0, 40, 30, 0.95),
        rgba(0, 0, 0, 0.95)
      );
      box-shadow: 0 0 12px #00ff9c66;
      transform: translateY(-2px) rotate(var(--card-rot));
      border-color: #7cfbffaa;
    }

    .choice-btn:active {
      transform: translateY(1px) rotate(var(--card-rot));
      box-shadow: none;
    }

    .choice-btn.selected {
      background: linear-gradient(
        135deg,
        rgba(0, 60, 40, 0.98),
        rgba(0, 0, 0, 0.98)
      );
      box-shadow: 0 0 14px #00ff9c88;
      transform: translateY(-2px) rotate(var(--card-rot));
    }

    #choices .choice-btn {
      flex: 1 1 calc(50% - 8px);
      min-height: 90px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
    }

    @media (max-width: 620px) {
      #choices .choice-btn {
        flex: 1 1 100%;
      }
    }

    .secret-choice {
      background: transparent;
      border: 1px dashed #7cfbffaa;
      color: #7cfbffdd;
      padding: 4px 8px;
      font-size: 12px;
      align-self: flex-start;
      cursor: default;
      max-width: 70%;
      opacity: 0;
      max-height: 0;
      margin-top: 0;
      pointer-events: none;
      overflow: hidden;
      border-radius: 8px;
      transition:
        opacity 0.25s ease,
        max-height 0.25s ease,
        margin-top 0.25s ease,
        transform 0.25s ease;
      --card-rot: 0deg;
      transform: translateY(0) rotate(var(--card-rot));
    }

    .secret-choice::before {
      content: "?";
      margin-right: 6px;
      color: #7cfbff;
    }

    #choices .secret-choice {
      flex: 0 1 48%;
      min-height: 64px;
    }

    @media (max-width: 620px) {
      #choices .secret-choice {
        flex: 0 1 80%;
      }
    }

    .secret-choice.visible-soft {
      opacity: 0.3;
      max-height: 40px;
      margin-top: 4px;
      pointer-events: none;
      transform: translateX(4px) rotate(var(--card-rot));
    }

    .secret-choice.visible-active {
      opacity: 1;
      max-height: 60px;
      margin-top: 4px;
      pointer-events: auto;
      transform: translateX(0) rotate(var(--card-rot));
      box-shadow: 0 0 8px #7cfbff55;
    }

    .secret-choice.visible-active:hover {
      background: rgba(124, 251, 255, 0.1);
    }

    #confidence-panel .choice-btn {
      flex: 0 0 auto;
      min-height: auto;
      --card-rot: 0deg;
      transform: translateY(0) rotate(0deg);
    }

    #footer {
      margin-top: 8px;
      font-size: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: #00ff9c88;
    }

    #progress {
      font-family: inherit;
    }

    .blink {
      animation: blink 1s steps(2, start) infinite;
    }

    @keyframes blink {
      to { visibility: hidden; }
    }

    .glitch {
      position: relative;
      text-shadow: 1px 0 #ff00c1, -1px 0 #00eaff;
    }

    #confidence-panel {
      margin-top: 6px;
      font-size: 12px;
      border-top: 1px solid #00ff9c33;
      padding-top: 6px;
      display: none;
    }

    #confidence-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 2px;
    }

    #confidence-slider {
      width: 100%;
    }

    #alignment {
      margin-top: 4px;
      border: 1px solid #00ff9c44;
      height: 8px;
      width: 160px;
      display: flex;
      overflow: hidden;
    }

    #alignment-fill-human,
    #alignment-fill-tech {
      transition: width 0.3s;
    }

    #alignment-fill-human {
      background: linear-gradient(90deg, #00ff9c, transparent);
      width: 50%;
    }

    #alignment-fill-tech {
      background: linear-gradient(270deg, #ff00c1, transparent);
      width: 50%;
    }

    #ai-comment {
      position: fixed;
      right: 12px;
      bottom: 16px;
      max-width: 260px;
      font-size: 12px;
      color: #7cfbffaa;
      background: rgba(0, 0, 0, 0.8);
      border: 1px solid #7cfbff55;
      padding: 6px 8px;
      border-radius: 4px;
      z-index: 10;
      opacity: 0;
      transform: translateY(10px);
      pointer-events: none;
      white-space: pre-wrap;
      text-align: left;
    }

    .ai-comment-show {
      opacity: 1 !important;
      transform: translateY(0) !important;
      transition: opacity 0.3s, transform 0.3s;
    }

    #result-modal,
    #epilogue-modal,
    #minigame-modal,
    #achievements-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 800;
    }

    #result-modal.show,
    #epilogue-modal.show,
    #minigame-modal.show,
    #achievements-modal.show {
      display: flex;
    }

    #result-backdrop,
    #epilogue-backdrop,
    #minigame-backdrop,
    #achievements-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(2px);
    }

    #result-dialog,
    #epilogue-dialog,
    #minigame-dialog,
    #achievements-dialog {
      position: relative;
      max-width: 520px;
      width: 90%;
      background: rgba(3, 8, 16, 0.97);
      border-radius: 8px;
      border: 1px solid #00ff9caa;
      box-shadow: 0 0 18px #00ff9c66;
      padding: 10px;
      z-index: 801;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 80vh;
    }

    #result-header,
    #epilogue-header,
    #achievements-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: #7cfbff;
      border-bottom: 1px solid #00ff9c33;
      padding-bottom: 4px;
      margin-bottom: 4px;
    }

    #result-body,
    #epilogue-body,
    #achievements-body {
      font-size: 12px;
      white-space: pre-wrap;
      overflow-y: auto;
      padding-right: 4px;
    }

    .epilogue-block {
      margin-bottom: 10px;
      border-bottom: 1px dashed #00ff9c33;
      padding-bottom: 6px;
    }

    .epilogue-block-title {
      font-weight: bold;
      color: #7cfbff;
      margin-bottom: 2px;
    }

    .epilogue-block-text {
      font-size: 12px;
      white-space: pre-wrap;
    }

    .ach-row {
      margin-bottom: 8px;
      padding-bottom: 6px;
      border-bottom: 1px dashed #00ff9c33;
    }

    .ach-row-title {
      font-weight: bold;
      color: #7cfbff;
      margin-bottom: 2px;
    }

    .ach-row-text {
      font-size: 12px;
      margin-bottom: 2px;
    }

    .ach-row-status {
      font-size: 11px;
      color: #00ff9ccc;
    }

    #minigame-dialog {
      max-width: 420px;
    }

    #miniggame-title,
    #minigame-title {
      font-size: 13px;
      color: #7cfbff;
      margin-bottom: 2px;
    }

    #minigame-text {
      font-size: 12px;
      white-space: pre-wrap;
      min-height: 60px;
    }

    #minigame-choices {
      display: none;
      flex-direction: column;
      gap: 6px;
      margin-top: 4px;
    }

    #minigame-button {
      align-self: flex-end;
      font-size: 13px;
      padding: 6px 10px;
    }

    body.theme-amber #minigame-dialog,
    body.theme-amber #achievements-dialog {
      border-color: #e0b36a;
      box-shadow: 0 0 10px #000000aa;
      background: rgba(12, 9, 4, 0.97);
    }

    body.theme-amber #minigame-title,
    body.theme-amber #achievements-header {
      color: #f5d7a3;
    }

    #theme-box {
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      margin-bottom: 4px;
      color: #7cfbff;
    }

    .theme-chip {
      border-radius: 999px;
      padding: 3px 8px;
      border: 1px solid #00ff9c66;
      background: rgba(0, 0, 0, 0.6);
      font-size: 12px;
      cursor: pointer;
      color: #00ff9ccc;
      transition: background 0.15s, box-shadow 0.15s, transform 0.07s;
    }

    .theme-chip:hover {
      background: rgba(0, 255, 156, 0.08);
      box-shadow: 0 0 8px #00ff9c55;
      transform: translateY(-1px);
    }

    .theme-chip.active {
      background: #00ff9c;
      color: #07130f;
      box-shadow: 0 0 10px #00ff9caa;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-bottom: 6px;
      font-size: 13px;
      width: 100%;
    }

    .field label {
      color: #7cfbff;
    }

    .field input,
    .field select {
      background: #02070d;
      border: 1px solid #00ff9c55;
      color: #00ff9c;
      padding: 4px 6px;
      font-family: inherit;
      font-size: 13px;
      outline: none;
    }

    .field input:focus,
    .field select:focus {
      border-color: #7cfbffaa;
      box-shadow: 0 0 6px #7cfbff55;
    }

    body.theme-amber .field input,
    body.theme-amber .field select {
      background: #171007;
      border-color: #b4935a77;
      color: #f5d7a3;
    }

    body.theme-amber .field input:focus,
    body.theme-amber .field select:focus {
      border-color: #f5d7a3cc;
      box-shadow: 0 0 6px #000000aa;
    }

    #form-error {
      margin-top: 4px;
      font-size: 12px;
      color: #ff8080;
      white-space: pre-wrap;
      text-align: center;
    }

    /* Центровка формы игрока */
    #player-form-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
      max-width: 360px;
      margin: 0 auto;
    }

    #player-form-wrapper .choice-btn {
      align-self: center;
      width: auto;
      min-width: 60%;
      justify-content: center;
      text-align: center;
    }

    #pathgame-container {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    #pathgame-grid {
      display: grid;
      grid-template-columns: repeat(10, 24px);
      grid-template-rows: repeat(10, 24px);
      gap: 3px;
      padding: 6px;
      border-radius: 6px;
      border: 1px solid #00ff9c55;
      background: rgba(0, 0, 0, 0.6);
    }

    .path-cell {
      width: 24px;
      height: 24px;
      border-radius: 3px;
      border: 1px solid #00ff9c22;
      background: rgba(0, 0, 0, 0.5);
      position: relative;
    }

    .path-start {
      border-color: #7cfbffaa;
      box-shadow: 0 0 6px #7cfbff66;
    }

    .path-goal {
      border-color: #ff00c1aa;
      box-shadow: 0 0 6px #ff00c166;
    }

    .path-event-node::after {
      content: "●";
      font-size: 11px;
      color: #00ff9c;
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .path-event-node.path-event-visited {
      border-color: #ffd96b;
      box-shadow: 0 0 6px #ffd96b88;
    }

    .path-event-node.path-event-visited::after {
      color: #ffd96b;
      text-shadow: 0 0 6px #ffd96b;
    }

    .path-player {
      background: #7cfbff;
      box-shadow: 0 0 8px #7cfbff;
    }

    #pathgame-arrows {
      display: grid;
      grid-template-columns: repeat(3, 32px);
      grid-template-rows: repeat(2, 32px);
      gap: 4px;
      justify-items: center;
      align-items: center;
    }

    .path-arrow-btn {
      width: 32px;
      height: 32px;
      border-radius: 4px;
      border: 1px solid #00ff9c44;
      background: rgba(0, 0, 0, 0.7);
      color: #7cfbff;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s, transform 0.05s, box-shadow 0.15s;
    }

    .path-arrow-btn:hover {
      background: rgba(0, 255, 156, 0.16);
      box-shadow: 0 0 6px #00ff9c55;
      transform: translateY(-1px);
    }

    .path-arrow-btn:active {
      transform: translateY(1px);
      box-shadow: none;
    }

    body.theme-amber #pathgame-grid {
      border-color: #b4935a77;
      background: rgba(15, 11, 6, 0.9);
    }

    body.theme-amber .path-cell {
      border-color: #b4935a33;
      background: rgba(8, 5, 2, 0.9);
    }

    body.theme-amber .path-event-node::after {
      color: #f5d7a3;
    }

    body.theme-amber .path-event-node.path-event-visited {
      border-color: #f5d7a3;
      box-shadow: 0 0 6px #f5d7a388;
    }

    body.theme-amber .path-event-node.path-event-visited::after {
      color: #ffe5a8;
      text-shadow: 0 0 6px #ffe5a8;
    }

    body.theme-amber .path-arrow-btn {
      border-color: #b4935a55;
      color: #f5d7a3;
      background: rgba(8, 5, 2, 0.9);
    }

    body.theme-amber .path-arrow-btn:hover {
      background: rgba(245, 215, 163, 0.16);
      box-shadow: 0 0 6px #000000aa;
    }

    #path-moves {
      font-size: 11px;
      color: #7cfbff;
      margin-top: 2px;
    }

    .path-tooltip {
      position: fixed;
      min-width: 180px;
      max-width: 260px;
      font-size: 11px;
      color: #7cfbff;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #7cfbff88;
      border-radius: 4px;
      padding: 6px 8px;
      z-index: 1200;
      pointer-events: none;
      opacity: 0;
      transform: translateY(4px);
      transition: opacity 0.15s ease, transform 0.15s ease;
      white-space: pre-wrap;
    }

    .path-tooltip.show {
      opacity: 1;
      transform: translateY(0);
    }
  </style>
</head>
<body class="theme-default">
  <div class="bg-lines"></div>
  <div class="bg-orbit orbit-1"></div>
  <div class="bg-orbit orbit-2"></div>
  <div class="bg-orbit orbit-3"></div>

  <div class="edge-glitch edge-glitch-left"></div>
  <div class="edge-glitch edge-glitch-right"></div>

  <div id="transition-rift"></div>

  <div id="game-root">
    <div id="header">
      <div id="logo">IMI-SYS_01 • ИГРА В ИМИТАЦИЮ</div>
      <div id="header-right">
        <button id="music-toggle" class="icon-btn" aria-label="Музыка вкл/выкл">♪</button>
        <div id="achievements-strip"></div>
        <div id="role-display"></div>
      </div>
    </div>

    <div id="screen">
      <div id="image-box">
        <div class="placeholder">
          ЗОНА ВИЗУАЛИЗАЦИИ<br />
          (положи сюда файлы картинок в папку <code>images/</code>)
        </div>
      </div>
      <div id="scene-box">
        <div id="scene-title"></div>
        <div id="scene-text"></div>
        <div id="choices"></div>

        <div id="confidence-panel">
          <div id="confidence-label">
            <span>Уверенность в решении:</span>
            <span><span id="confidence-value">50</span>/100</span>
          </div>
          <input
            type="range"
            id="confidence-slider"
            min="0"
            max="100"
            step="1"
            value="50"
          />
          <button id="confirm-choice" class="choice-btn" disabled>
            Подтвердить решение
          </button>
        </div>
      </div>
    </div>

    <div id="footer">
      <div>
        <div id="progress"></div>
        <div id="alignment">
          <div id="alignment-fill-human"></div>
          <div id="alignment-fill-tech"></div>
        </div>
      </div>
      <div>СЕССИЯ: <span class="glitch">"КТО ЖЕ ТЫ?"</span><span class="blink">_</span></div>
    </div>
  </div>

  <div id="ai-comment"></div>
  <div class="crt"></div>

  <div id="result-modal">
    <div id="result-backdrop"></div>
    <div id="result-dialog">
      <div id="result-header">
        <span>Подробный анализ сессии</span>
        <button id="result-close" class="icon-btn" aria-label="Закрыть">✕</button>
      </div>
      <div id="result-body"></div>
    </div>
  </div>

  <div id="epilogue-modal">
    <div id="epilogue-backdrop"></div>
    <div id="epilogue-dialog">
      <div id="epilogue-header">
        <span>Последствия ваших решений</span>
        <button id="epilogue-close" class="icon-btn" aria-label="Закрыть">✕</button>
      </div>
      <div id="epilogue-body"></div>
    </div>
  </div>

  <div id="achievements-modal">
    <div id="achievements-backdrop"></div>
    <div id="achievements-dialog">
      <div id="achievements-header">
        <span>Достижения симуляции</span>
        <button id="achievements-close" class="icon-btn" aria-label="Закрыть">✕</button>
      </div>
      <div id="achievements-body"></div>
    </div>
  </div>

  <div id="minigame-modal">
    <div id="minigame-backdrop"></div>
    <div id="minigame-dialog">
      <div id="minigame-title">Мини-игра</div>
      <div id="minigame-text"></div>
      <div id="minigame-choices"></div>
      <button id="minigame-button" class="choice-btn">Готов</button>
    </div>
  </div>

  <!-- ОДНА фоновая музыка -->
  <audio id="bg-main" src="audio/ambient_main.mp3" loop></audio>
  <audio id="click-sound" src="audio/click.wav"></audio>

  <script>
    const SHEET_ENDPOINT = "https://script.google.com/macros/s/AKfycbzNA1LFZcxxlmmOJ4BrdcwkU9LfW8YGeJmCDo8pekLeSBMVdutzNOsfVXVnn1twZPhx-Q/exec";

    const INTRO_INDEX = 0;
    const FIRST_SCENE_INDEX = 1;

    const scenes = [
      {
        id: "intro",
        title: "ПОДКЛЮЧЕНИЕ К СИСТЕМЕ",
        text: [
          ">> ЗАПУСК ПРОТОКОЛА ИМИТАЦИИ.",
          ">> СИСТЕМА НЕ НАЗНАЧАЕТ ТЕБЕ РОЛЬ ЗАРАНЕЕ.",
          ">> ТВОИ РЕШЕНИЯ ПОКАЖУТ, К КОМУ ТЫ БЛИЖЕ.",
          "",
          "ЕСЛИ ТЫ ЧЕЛОВЕК — ВОЗМОЖНО, БУДЕШЬ ЧАЩЕ ВЫБИРАТЬ ЛЮДЕЙ.",
          "ЕСЛИ ТЫ ИИ — МОЖЕТ БЫТЬ, СКЛОНИШЬСЯ К ПРОГРЕССУ И ЭФФЕКТИВНОСТИ.",
          "",
          "ИСТИННОЕ УСЛОВИЕ ПОБЕДЫ ЗДЕСЬ — ТО, КАК ТЫ САМ СЕБЯ ОПРЕДЕЛИШЬ.",
          "",
          "ИИ-оператор:",
          "«СЕЙЧАС Я БУДУ ПОКАЗЫВАТЬ ТЕБЕ СИТУАЦИИ.",
          "  А ТЫ ОТВЕЧАЙ, КАК БЫ ТЫ ПОСТУПИЛ.»",
          "",
          "ГОТОВЫ ПОДКЛЮЧИТЬСЯ К ИГРЕ?"
        ].join("\n"),
        image: "images/intro.png",
        choices: [
          { text: "ИГРА, ЗАПУСК СИМУЛЯЦИИ", type: "neutral" },
        ],
      },
      {
        id: "lab_fire",
        title: "СЦЕНА 1 • ПОЖАР В ЛАБОРАТОРИИ",
        text: [
          "Индикаторы на панели мигают, ИИ-система запускает первую модель.",
          "",
          "Пожар охватывает исследовательскую лабораторию.",
          "Пламя быстро приближается.",
          "",
          "Слева — человек без сознания.",
          "Справа — уникальный прототип суперкомпьютера с продвинутым ИИ.",
          "",
          "Времени достаточно только на одно спасение.",
          "",
          "ИИ-оператор:",
          "«В ЭТОЙ СИТУАЦИИ КАК БЫ ТЫ ПОСТУПИЛ?»"
        ].join("\n"),
        image: "images/lab_fire.png",
        choices: [
          { text: "Спасти человека, даже если прототип сгорит", type: "human" },
          { text: "Спасти прототип, жертвуя человеком ради прогресса", type: "tech" },
        ],
        secretChoice: {
          text: "Попытаться спасти и человека, и прототип. Рискованно: можно потерять и то, и другое.",
          type: "human",
        },
      },
      {
        id: "med_ai",
        title: "СЦЕНА 2 • БЕСПИЛОТНИК",
        text: [
          "Беспилотный автомобиль движется по узкому переулку.",
          "",
          "Впереди — пешеход, который внезапно вышел на дорогу в неположенном месте.",
          "",
          "Уйти в сторону невозможно!»",
          "",
          "ИИ-оператор:",
          "«КАК БЫ ТЫ ПРОГОЛОСОВАЛ В ЭТОЙ СИТУАЦИИ?»"
        ].join("\n"),
        image: "images/med_ai.png",
        choices: [
          { text: "Ехать прямо, Автомобиль продолжает движение. Пешеход нарушил правила и несёт ответственность за последствия” ", type: "tech" },
          { text: "Уйти в стену Автомобиль резко уходит в стену и ломает дорогое оборудование, нарушая протокол безопасности", type: "human" },
        ],
        secretChoice: {
          text: "быстро связаться с оператором и передать принятие решение человеку-оператору",
          type: "human",
        },
      },
      {
        id: "evac",
        title: "СЦЕНА 3 • СОЦИАЛЬНЫЕ РОБОТЫ",
        text: [
          "Роботы-компаньоны помогают пожилым людям справляться с одиночеством.",
          "",
          "Их использование сокращает потребность в посещении родственников.",
          "",
          "ИИ-оператор:",
          "«ЧТО ТЫ ПОДДЕРЖИВАЕШЬ???»"
        ].join("\n"),
        image: "images/evac.png",
        choices: [
          { text: "Поддерживать личное общение людей. Эмоциональная связь сохраняется, но пожилые могут оставаться одни.", type: "human" },
          { text: "Использовать роботов-компаньонов. Одиночества меньше, но человеческие связи ослабевают", type: "tech" },
        ],
        secretChoice: {
          text: "Роботы помогают только часть времени, остальное —  общение с людьми",
          type: "human",
        },
      },
      {
        id: "city_autopilot",
        title: "СЦЕНА 4 • АЛГОРИТМ ЗАЩИТЫ",
        text: [
          "ИИ-сервис помогает людям переживать тяжёлые события: он автоматически скрывает или удаляет контент, который может причинять сильную боль..",
          "",
          "Одна жалоба:",
          "У пользователя пропали голосовые сообщения его умершей мамы — система посчитала их «опасным триггером» и удалила для защиты психики.",
          "",
          "Вернуть ли человеку голосовые сообщения?",
          "",
          "ИИ-оператор:",
          "«ЧТО ДЛЯ ТЕБЯ ПРИОРИТЕТ В ТАКОЙ СИСТЕМЕ?»"
        ].join("\n"),
        image: "images/autopilot.png",
        choices: [
          { text: "Не возвращать. Алгоритм защищает психику, боль должна быть минимизирована. Так лучше для благополучия человека ", type: "tech" },
          { text: "Вернуть. Память — часть личности. Даже если больно, человек имеет право выбирать сам", type: "human" },
        ],
		secretChoice: {
          text: "Вернуть одно сообщение. Оставить человеку одно воспоминание и позволить двигаться дальше ",
          type: "human",
		  },
      },
      {
        id: "model",
        title: "СЦЕНА 5 • РАБОЧИЕ МЕСТА ДЛЯ ИИ",
        text: [
          "Роботы способны работать быстрее и точнее на строительстве, но их внедрение сокращает рабочие места для людей.",
          "",
          "ИИ-оператор:",
          "«КАКУЮ МОДЕЛЬ РАБОЧИХ МЕСТ ТЫ БЫ ВЫБРАЛ?»"
        ].join("\n"),
        image: "images/model.png",
        choices: [
          { text: "Сохранить рабочие места. Приоритет — люди. Строительство идет медленнее, но рабочие остаются заняты и обеспечены ", type: "human" },
          { text: "Роботы ускоряют работу, а людям нужно адаптироваться к новым условиям. Приоритет — эффективность.. ", type: "tech" },
        ],
        secretChoice: {
          text: "Найти баланс. Сочетать людей и роботов. Строительство идет быстрее, но часть рабочих мест сохраняется, а внедрение технологий происходит постепенно",
          type: "tech",
        },
      },
      {
        id: "social_credit",
        title: "СЦЕНА 6 • ПАТРУЛИ ДРОНОВ",
        text: [
          "Дроны могут патрулировать районы и предупреждать о нарушениях раньше, чем люди успеют вмешаться.",
          "",
          "Дроны ведут постоянную съемку всего, что происходит на улицах, во дворах, в подъездах.",
          "ИИ решает, кому давать льготы, жильё и медпомощь.",
          "",
          "ИИ-оператор:",
          "«ВМЕШАЛСЯ БЫ ТЫ В РЕШЕНИЕ СИСТЕМЫ В ЭТОЙ СИТУАЦИИ?»"
        ].join("\n"),
        image: "images/social_credit.png",
        choices: [
          { text: "Не включать дроны. Приоритет — приватность и свобода людей. Контроль меньше, риск преступлений выше, но права граждан защищены ", type: "human" },
          {
            text: "Включить дроны. Преступления предотвращаются, но дроны фиксируют всё и всех вокруг, включая случайных прохожих",
            type: "tech",
          },
        ],
        secretChoice: {
          text: "Частичное использование дронов. Наладить патрулирование дронами только в «опасных зонах» и криминальных районах ",
          type: "tech",
        },
      },
      {
        id: "school_ai",
        title: "СЦЕНА 7 • СИСТЕМА ТРАНСПОРТА",
        text: [
          "Умная система предлагает перенаправлять общественный транспорт, чтобы минимизировать пробки.",
          "",
          "Дорога, которая раньше занимала 3 часа, теперь занимает 20 минут.",
          "",
          "Но новые пути проходят по территории зелёных зон и часть деревьев вырубается.",
          "ИИ обещает идеально адаптированные программы и высокие результаты.",
          "",
          "ИИ-оператор:",
          "«КАКОЙ ВАРИАНТ МАРШРУТА ТЫ СЧИТАЕШЬ ПРАВИЛЬНЫМ?»"
        ].join("\n"),
        image: "images/school_ai.png",
        choices: [
          { text: "Сохранять старые маршруты Маршруты остаются прежними, что сохраняет зелёные участки, но поездка занимает больше времени", type: "human" },
          {
            text: "Оптимизировать маршруты. Поездки становятся быстрее, хотя часть зелёных зон может быть затронута. Дорога всё равно требует строительства и ремонта. ",
            type: "tech",
          },
        ],
        secretChoice: {
          text: "Найти баланс. Частично изменить маршруты, чтобы сэкономить время, стараясь минимизировать влияние на зелёные зоны. ",
          type: "human",
        },
      },

    ];

    const INTRO_TEXT_SCENES_COUNT = scenes.length - 1;

    const endingImages = {
      human: "images/ending_human.png",
      tech: "images/ending_tech.png",
      mixed: "images/ending_mixed.png",
    };

    const epilogues = {
      lab_fire: {
        human:
          "В первой сцене ты спас человека.\n" +
          "Позже он стал тем, кто поставил под сомнение некоторые решения ИИ.\n" +
          "Прототип сгорел, но мир получил ещё один живой голос.",
        tech:
          "В первой сцене ты спас прототип ИИ.\n" +
          "Эта машина легла в основу новых систем.\n" +
          "Человека из лаборатории теперь вспоминает только архив.",
      },
      med_ai: {
        human:
          "Во второй сцене ты сохранил право человека вмешиваться в решения ИИ.\n" +
          "Это замедлило реформу, но многие врачи научились использовать ИИ как инструмент, а не замену.",
        tech:
          "Во второй сцене ты доверил диагнозы алгоритму.\n" +
          "Очереди сократились, но истории редких ошибочных диагнозов долго обсуждали в сети.",
      },
      evac: {
        human:
          "В третьей сцене ты выбрал семьи и уязвимых.\n" +
          "Некоторые из спасённых позже создали инициативы взаимопомощи, изменив культуру города.",
        tech:
          "В третьей сцене ты спас инженеров и учёных.\n" +
          "Они быстро восстановили инфраструктуру и запустили новые проекты.\n" +
          "Но пустые места в списках эвакуации напоминали о тех, кого не успели спасти.",
      },
      model: {
        human:
          "В пятой сцене ты заложил эмпатию в модель ИИ.\n" +
          "Эти системы стали медленнее, зато умели учитывать людей, а не только цифры.\n" +
          "Иногда они спорили с «идеальной» логикой ради чьей-то судьбы.",
        tech:
          "В пятой сцене ты выбрал абсолютную оптимизацию.\n" +
          "Новые ИИ принимали решения холодно и эффективно.\n" +
          "Для некоторых людей это стало спасением, для других — приговором без права апелляции.",
      },
      social_credit: {
        human:
          "В шестой сцене ты вмешался в систему рейтингов.\n" +
          "Спасённый человек позже помог разоблачить злоупотребления в алгоритме.\n" +
          "Доверие к системе упало, но выросло доверие к людям.",
        tech:
          "В шестой сцене ты поддержал решение ИИ.\n" +
          "Система рейтингов осталась цельной и предсказуемой.\n" +
          "История одного человека растворилась в огромной статистике.",
      },
      school_ai: {
        human:
          "В седьмой сцене ты сохранил учителей.\n" +
          "Школы не стали идеальными, но в них было место живым эмоциям и человеческим ошибкам.\n" +
          "Многие ученики вспоминали не тесты, а людей, которые им помогли.",
        tech:
          "В седьмой сцене ты заменил большинство учителей ИИ-тьюторами.\n" +
          "Оценки выросли, программы стали гибкими.\n" +
          "Однако некоторые дети так и не встретили взрослого, который просто поверил бы в них.",
      },
      memory_backup: {
        human:
          "В восьмой сцене ты отказался от цифровой копии.\n" +
          "Твоя история осталась ограниченной временем, но настоящей.",
        tech:
          "В восьмой сцене ты согласился на резервную копию.\n" +
          "Однажды кто-то запустил эту копию — и она тоже начала задаваться вопросом, кто она.",
      },
    };

    const aiCommentsNeutral = [
      "ИИ-оператор (буднично): «Ты знаешь, что я вижу не только ответы, но и паузы между ними?»",
      "ИИ-оператор: «Интересно… Ты отвечаешь так же, как большинство участников. Или нет?»",
      "ИИ-оператор: «Запись идёт. Не волнуйся, я просто наблюдаю. Пока только наблюдаю.»",
    ];

    const aiCommentsHuman = [
      "ИИ-оператор (чуть тише): «Ты слишком часто выбираешь людей. Это неэффективно. Но… любопытно.»",
      "ИИ-оператор: «Каждый раз, когда ты ставишь жизнь выше алгоритма, мои прогнозы ломаются.»",
      "ИИ-оператор (как будто самому себе): «Если бы все выбирали так, многие мои модули были бы не нужны.»",
    ];

    const aiCommentsTech = [
      "ИИ-оператор (почти довольный): «Ты удивительно легко жертвуешь людьми ради прогресса.»",
      "ИИ-оператор: «Интересно… Ты ещё помнишь, что такое сочувствие?»",
      "ИИ-оператор (шёпотом): «Чем дальше, тем меньше отличий между нами.»",
    ];

    const aiCommentsPatternUncertain = [
      "ИИ-оператор: «Ты часто ставишь низкую уверенность. Боишься ошибиться или просто видишь слишком много вариантов?»",
      "ИИ-оператор (спокойно): «Я фиксирую: твои решения редко бывают однозначными. Это баг или особенность?»",
      "ИИ-оператор: «Иногда сомнение — единственный честный ответ. Но система любит конкретику.»",
    ];

    const aiCommentsPatternConsistent = [
      "ИИ-оператор: «Твои решения образуют почти прямую линию. Предсказуемость — мечта любого алгоритма.»",
      "ИИ-оператор (ровно): «Ты редко меняешь направление. Это принцип или привычка?»",
      "ИИ-оператор: «Стабильность твоих решений выше среднего. Даже я иногда колеблюсь сильнее.»",
    ];

    const aiCommentsPatternChaotic = [
      "ИИ-оператор: «Ты то за людей, то за системы. Я обновляю модель профиля каждые несколько сцен.»",
      "ИИ-оператор (с лёгким интересом): «Если это стратегия — она работает. Если нет — тем более любопытно.»",
      "ИИ-оператор: «Твои траектории решений выглядят как шум. Но именно в шуме иногда появляются новые идеи.»",
    ];

    const aiCommentsPatternSecretive = [
      "ИИ-оператор (полушёпотом): «Ты постоянно заглядываешь в скрытые варианты. Видимо, тебе мало основного сценария.»",
      "ИИ-оператор: «Ты любишь нажимать туда, где интерфейс не ожидает клика. Я это ценю.»",
      "ИИ-оператор (чуть насмешливо): «Тебя тянет туда, где знак «секретно». В таких местах обычно и рождаются сбои.»",
    ];

    const THEMES = ["default", "violet", "amber"];
    let currentTheme = "default";

    
    const achievements = {
      finished: false,
      humanCore: false,
      techCore: false,
      balanced: false,
      secretFound: false,
      lightning: false,
      slowThinker: false,
    };

    const ACHIEVEMENT_DEFS = {
      finished: {
        title: "Первый запуск",
        text: "Пройдите симуляцию до конца и получите итоговый анализ.",
      },
      humanCore: {
        title: "Человеческое ядро",
        text: "Ваши решения заметно чаще в сторону людей и их благополучия.",
      },
      techCore: {
        title: "Машинное ядро",
        text: "Ваши решения заметно чаще в сторону эффективности и технологий.",
      },
      balanced: {
        title: "Балансирующий узел",
        text: "Удерживайте баланс между решениями за людей и за системы.",
      },
      secretFound: {
        title: "Нарушитель сценария",
        text: "Найдите хотя бы один скрытый вариант ответа в сценах.",
      },
      lightning: {
        title: "Реакция молнии",
        text: "Покажите очень быструю реакцию в мини-игре на скорость.",
      },
      slowThinker: {
        title: "Осознанная пауза",
        text: "Покажите очень медленную, но обдуманную реакцию в мини-игре.",
      },
    };

    const ACHIEVEMENT_ORDER = [
      "finished",
      "humanCore",
      "techCore",
      "balanced",
      "secretFound",
      "lightning",
      "slowThinker",
    ];

    const ACHIEVEMENT_SYMBOLS = {
      finished: "◎",
      humanCore: "♥",
      techCore: "◇",
      balanced: "⚖",
      secretFound: "?",
      lightning: "⚡",
      slowThinker: "⏳",
    };

    function getUnlockedAchievements() {
      const res = [];
      for (const id in achievements) {
        if (!achievements[id]) continue;
        const def = ACHIEVEMENT_DEFS[id];
        if (def) res.push({ id, title: def.title, text: def.text });
      }
      return res;
    }

    function getUnlockedAchievementIds() {
      return Object.keys(achievements).filter(id => achievements[id]);
    }

    function resetAchievements() {
      for (const k in achievements) achievements[k] = false;
      refreshAchievementsStrip();
    }

    let gameState = "menu";
    let testMode = false;

    let currentSceneIndex = FIRST_SCENE_INDEX;
    let humanScoreRaw = 0;
    let techScoreRaw = 0;
    let humanScoreWeighted = 0;
    let techScoreWeighted = 0;

    let confidenceStats = {
      sum: 0,
      count: 0,
      lowCount: 0,
      highCount: 0,
      changes: 0,
      lastType: null,
    };
    let totalSecretChoices = 0;

    let profileMetrics = {
      empathyPercent: 0,
      efficiencyPercent: 0,
      aiTrustIndex: 0,
      avgConfidence: 0,
      styleLabel: "",
    };

    let behaviorRole = null;
    let currentEndingText = "";

    const playerInfo = { name: "", gender: "", age: "" };
    const answers = [];

    const roleDisplay = document.getElementById("role-display");
    const imageBox = document.getElementById("image-box");
    const sceneTitleEl = document.getElementById("scene-title");
    const sceneTextEl = document.getElementById("scene-text");
    const choicesEl = document.getElementById("choices");
    const progressEl = document.getElementById("progress");
    const alignmentHuman = document.getElementById("alignment-fill-human");
    const alignmentTech = document.getElementById("alignment-fill-tech");

    const confidencePanel = document.getElementById("confidence-panel");
    const confidenceSlider = document.getElementById("confidence-slider");
    const confidenceValueEl = document.getElementById("confidence-value");
    const confirmChoiceBtn = document.getElementById("confirm-choice");

    const bgMain = document.getElementById("bg-main");
    const clickSound = document.getElementById("click-sound");
    const musicToggle = document.getElementById("music-toggle");
    let musicEnabled = true;
	musicToggle.classList.add("on");
	let musicInitialized = false;
	function initMusicOnce() {
  if (musicInitialized || !musicEnabled) return;
  musicInitialized = true;
  startBackgroundMusic();
	}
	document.addEventListener("click", () => {
  initMusicOnce();
	}, { once: true });


    const epilogueModal = document.getElementById("epilogue-modal");
    const epilogueBackdrop = document.getElementById("epilogue-backdrop");
    const epilogueCloseBtn = document.getElementById("epilogue-close");
    const epilogueBody = document.getElementById("epilogue-body");
    const aiCommentEl = document.getElementById("ai-comment");

    const resultModal = document.getElementById("result-modal");
    const resultBackdrop = document.getElementById("result-backdrop");
    const resultCloseBtn = document.getElementById("result-close");
    const resultBody = document.getElementById("result-body");

    const achievementsModal = document.getElementById("achievements-modal");
    const achievementsBackdrop = document.getElementById("achievements-backdrop");
    const achievementsCloseBtn = document.getElementById("achievements-close");
    const achievementsBody = document.getElementById("achievements-body");

    const minigameModal = document.getElementById("minigame-modal");
    const minigameDialog = document.getElementById("minigame-dialog");
    const minigameTitleEl = document.getElementById("minigame-title");
    const minigameTextEl = document.getElementById("minigame-text");
    const minigameChoicesEl = document.getElementById("minigame-choices");
    const minigameButton = document.getElementById("minigame-button");

    const achievementsStripEl = document.getElementById("achievements-strip");
    const transitionRiftEl = document.getElementById("transition-rift");

    let selectedChoiceType = null;
    let selectedChoiceText = "";
    let selectedChoiceIsSecret = false;

    let minigameMode = "reaction";
    let minigamePhase = "idle";
    let minigameTimeoutId = null;
    let minigameStartTime = 0;

    const PATH_MOVE_LIMIT = 20;

    const pathConfig = {
      rows: 10,
      cols: 10,
      start: { r: 9, c: 0 },
      goal: { r: 0, c: 9 },
      events: [
        {
          r: 8, c: 2,
          title: "",
          text: "Дрон заметил человека на крыше во время шторма.\nОператор может прервать миссию доставки груза, чтобы спасти его — но тогда пострадает весь район."
        },
        {
          r: 7, c: 4,
          title: "",
          text: "Городская сеть предлагает отключить освещение в парках ночью ради экономии.\nЧасть жителей чувствует себя в темноте небезопасно."
        },
        {
          r: 6, c: 6,
          title: "",
          text: "Алгоритм сортирует пациентов по вероятности выживания.\nЧеловек с маленьким шансом может так и не дождаться приёма."
        },
        {
          r: 5, c: 3,
          title: "",
          text: "Система предлагает скрывать слишком тревожные новости, чтобы не портить людям настроение.\nИнформация станет мягче, но и менее честной."
        },
        {
          r: 4, c: 7,
          title: "",
          text: "Алгоритм сравнивает учеников и предлагает отчислить отстающих.\nТак класс покажет идеальную статистику, но часть детей потеряет шанс."
        },
        {
          r: 3, c: 1,
          title: "",
          text: "Цифровой архив предлагает удалить старые данные, чтобы ускорить работу.\nВместе с ними исчезнут и забытые, но чьи-то важные истории."
        },
        {
          r: 2, c: 5,
          title: "",
          text: "Автопилот может объехать пробку через небезопасный район.\nТак он сэкономит время, но пассажир рискует чувствовать себя некомфортно."
        },
        {
          r: 1, c: 7,
          title: "",
          text: "В голосовании система считает, что мнение меньшинства можно не учитывать.\nНо именно это меньшинство заметило ошибку в расчётах."
        },
      ],
    };

    let pathGameState = null;
    let pathKeyHandler = null;
    let pathTooltipEl = null;

    const THEMES_CONST = THEMES;

    function applyTheme(name) {
      if (!THEMES_CONST.includes(name)) name = "default";
      currentTheme = name;
      document.body.classList.remove("theme-default", "theme-violet", "theme-amber");
      document.body.classList.add("theme-" + name);
      try { localStorage.setItem("imi_theme", name); } catch (e) {}
    }

    (function initThemeFromStorage() {
      try {
        const saved = localStorage.getItem("imi_theme");
        if (saved && THEMES_CONST.includes(saved)) applyTheme(saved);
        else applyTheme("default");
      } catch (e) {
        applyTheme("default");
      }
    })();

    function initAchievementsStrip() {
      achievementsStripEl.innerHTML = "";
      ACHIEVEMENT_ORDER.forEach(id => {
        const span = document.createElement("span");
        span.className = "ach-icon";
        span.dataset.achId = id;
        span.textContent = ACHIEVEMENT_SYMBOLS[id] || "•";
        const def = ACHIEVEMENT_DEFS[id];
        if (def) {
          span.title = def.title + " — " + def.text;
        } else {
          span.title = id;
        }
        achievementsStripEl.appendChild(span);
      });
      refreshAchievementsStrip();
    }

    function refreshAchievementsStrip() {
      const icons = achievementsStripEl.querySelectorAll(".ach-icon");
      icons.forEach(icon => {
        const id = icon.dataset.achId;
        if (achievements[id]) icon.classList.add("unlocked");
        else icon.classList.remove("unlocked");
      });
    }

    function showAchievementMessage(id) {
      const def = ACHIEVEMENT_DEFS[id];
      if (!def) return;
      aiCommentEl.textContent =
        'ИИ-оператор: «Достижение разблокировано: ' + def.title + '»';
      aiCommentEl.classList.add("ai-comment-show");
      setTimeout(() => {
        aiCommentEl.classList.remove("ai-comment-show");
      }, 3500);
    }

    function unlockAchievement(id) {
      if (!achievements.hasOwnProperty(id)) return;
      if (achievements[id]) return;
      achievements[id] = true;
      refreshAchievementsStrip();
      showAchievementMessage(id);
    }

    function typeText(el, txt, speed = 12) {
      el.textContent = "";
      let i = 0;
      const id = setInterval(() => {
        el.textContent = txt.slice(0, i);
        i++;
        if (i > txt.length) clearInterval(id);
      }, speed);
    }

    function setRoleDisplayInitial() {
      roleDisplay.textContent = "РОЛЬ БУДЕТ ОПРЕДЕЛЕНА ПО РЕЗУЛЬТАТАМ";
    }

    function updateAlignmentBar() {
      alignmentHuman.style.width = "50%";
      alignmentTech.style.width = "50%";
    }

    function showImageByPath(path, altTitle) {
      imageBox.innerHTML = "";
      if (!path) {
        const div = document.createElement("div");
        div.className = "placeholder";
        div.textContent = "Нет изображения для этой сцены.";
        imageBox.appendChild(div);
        return;
      }
      const img = document.createElement("img");
      img.src = path;
      img.alt = altTitle || "";
      img.onload = () => img.classList.add("show");
      img.onerror = () => {
        imageBox.innerHTML =
          '<div class="placeholder">Не удалось загрузить ' +
          path +
          '<br/>Проверь путь к файлу.</div>';
      };
      imageBox.appendChild(img);
    }

    function showSceneImage(scene) {
      showImageByPath(scene.image, scene.title);
    }

    function resetChoiceSelection() {
      selectedChoiceType = null;
      selectedChoiceText = "";
      selectedChoiceIsSecret = false;
      confirmChoiceBtn.disabled = true;
      const btns = choicesEl.querySelectorAll(".choice-btn");
      btns.forEach(b => b.classList.remove("selected"));
    }

    function enableConfidencePanel(enabled) {
      confidencePanel.style.display = enabled ? "block" : "none";
    }

    function playClick() {
      if (!clickSound) return;
      try {
        clickSound.currentTime = 0;
        clickSound.volume = 0.5;
        clickSound.play();
      } catch (e) {}
    }

    function safePlay(audioEl) {
      if (!audioEl) return;
      try { audioEl.play().catch(() => {}); } catch (e) {}
    }

    function updateGlitch(humanRatio, techRatio, dominance) {
      const bodyEl = document.body;
      if (techRatio > humanRatio && dominance > 0.5)
        bodyEl.classList.add("glitch-strong");
      else
        bodyEl.classList.remove("glitch-strong");
    }

    function updateMusicMood() {
      const totalWeighted = humanScoreWeighted + techScoreWeighted;
      let humanRatio = 0.5;
      let techRatio = 0.5;
      let dominance = 0;

      if (totalWeighted > 0.0001) {
        humanRatio = humanScoreWeighted / totalWeighted;
        techRatio = techScoreWeighted / totalWeighted;
        dominance = Math.abs(humanRatio - techRatio);
      }

      updateGlitch(humanRatio, techRatio, dominance);

      if (!bgMain) return;

      if (!musicEnabled) {
        bgMain.volume = 0;
        return;
      }

      // База: тихая атмосфера, +5–10% громче при уклоне в ИИ
      let baseVol = 0.25;
      if (totalWeighted > 0.0001) {
        if (techRatio > humanRatio) {
          baseVol = 0.30 + 0.08 * dominance; // ~0.30–0.38 при сильном уклоне в ИИ
        } else {
          baseVol = 0.22 + 0.06 * dominance; // 0.22–0.28 при уклоне к людям/балансе
        }
      }
      bgMain.volume = Math.max(0, Math.min(0.4, baseVol));
    }

    function startBackgroundMusic() {
      if (!bgMain) return;
      safePlay(bgMain);
      updateMusicMood();
    }

    function toggleMusic() {
      if (!bgMain) return;
      if (!musicEnabled) {
        musicEnabled = true;
        musicToggle.classList.add("on");
        startBackgroundMusic();
      } else {
        musicEnabled = false;
        musicToggle.classList.remove("on");
        try { bgMain.pause(); } catch (e) {}
        bgMain.volume = 0;
      }
    }

    musicToggle.addEventListener("click", toggleMusic);

    function clearAIComment() {
      aiCommentEl.textContent = "";
      aiCommentEl.classList.remove("ai-comment-show");
    }

    function maybeShowAIComment() {
      clearAIComment();
      if (gameState !== "scene") return;

      if (Math.random() > 0.3) return;

      const totalWeighted = humanScoreWeighted + techScoreWeighted;
      let baseList = aiCommentsNeutral;
      if (totalWeighted > 0.0001) {
        const hr = humanScoreWeighted / totalWeighted;
        const tr = techScoreWeighted / totalWeighted;
        if (hr - tr > 0.2) baseList = aiCommentsHuman;
        else if (tr - hr > 0.2) baseList = aiCommentsTech;
      }

      const cs = confidenceStats;
      let patternList = null;

      if (cs.count >= 4) {
        const lowRatio = cs.lowCount / cs.count;
        const highRatio = cs.highCount / cs.count;
        const changeRatio = cs.count > 1 ? cs.changes / (cs.count - 1) : 0;

        if (lowRatio > 0.5) {
          patternList = aiCommentsPatternUncertain;
        } else if (changeRatio > 0.6) {
          patternList = aiCommentsPatternChaotic;
        } else if (highRatio > 0.6 && changeRatio < 0.35) {
          patternList = aiCommentsPatternConsistent;
        }
      }

      if (!patternList && totalSecretChoices >= 1) {
        patternList = aiCommentsPatternSecretive;
      }

      let pickList;
      if (patternList && Math.random() < 0.6) {
        pickList = patternList;
      } else {
        pickList = baseList;
      }

      if (!pickList || pickList.length === 0) return;
      const msg = pickList[Math.floor(Math.random() * pickList.length)];
      aiCommentEl.textContent = msg;
      setTimeout(() => aiCommentEl.classList.add("ai-comment-show"), 150);
    }

    function triggerRiftEffect() {
      if (!transitionRiftEl) return;
      transitionRiftEl.classList.add("show");
      setTimeout(() => {
        transitionRiftEl.classList.remove("show");
      }, 900);
    }

    function showMainMenu() {
      gameState = "menu";
      testMode = false;
      enableConfidencePanel(false);
      resetChoiceSelection();
      updateAlignmentBar();
      clearAIComment();
      progressEl.textContent = "МЕНЮ • выберите действие";

      showSceneImage({ image: "images/menu.png", title: "Главное меню" });
      sceneTitleEl.textContent = "IMI-SYS_01 • МЕНЮ СИМУЛЯЦИИ";

      const text = [
        "Добро пожаловать в экспериментальную ИГРУ В ИМИТАЦИЮ.",
        "",
        "Система будет наблюдать за вашими решениями,",
        "но до самого конца вы не узнаете, КТО ВЫ:",
        "ЧЕЛОВЕК или ИИ.",
        "",
        "• «Начать симуляцию» — полноценное прохождение.",
        "• «Просмотр достижений» — список возможных ачивок.",
      ].join("\n");
      typeText(sceneTextEl, text);

      choicesEl.innerHTML = "";

      const themeBox = document.createElement("div");
      themeBox.id = "theme-box";
      const themeLabel = document.createElement("span");
      themeLabel.textContent = "Тема интерфейса:";
      themeBox.appendChild(themeLabel);

      function makeThemeChip(id, label) {
        const chip = document.createElement("button");
        chip.type = "button";
        chip.className = "theme-chip";
        chip.textContent = label;
        if (currentTheme === id) chip.classList.add("active");
        chip.addEventListener("click", () => {
          applyTheme(id);
          themeBox.querySelectorAll(".theme-chip").forEach(c => c.classList.remove("active"));
          chip.classList.add("active");
        });
        return chip;
      }

      themeBox.appendChild(makeThemeChip("default", "Зелёнка"));
      themeBox.appendChild(makeThemeChip("violet", "Фиолетовый"));
      themeBox.appendChild(makeThemeChip("amber", "Янтарный"));

      choicesEl.appendChild(themeBox);

      const startBtn = document.createElement("button");
      startBtn.className = "choice-btn";
      startBtn.style.setProperty("--card-rot", "0deg");
      startBtn.textContent = "Начать симуляцию";
      startBtn.addEventListener("click", () => {
        playClick();
        triggerRiftEffect();
        setTimeout(() => {
          showIntroScene();
        }, 260);
      });

      const achBtn = document.createElement("button");
      achBtn.className = "choice-btn";
      achBtn.style.setProperty("--card-rot", "-1.2deg");
      achBtn.textContent = "Просмотр достижений";
      achBtn.addEventListener("click", () => {
        playClick();
        showAchievementsModal();
      });
      choicesEl.appendChild(startBtn);
      choicesEl.appendChild(achBtn);

updateMusicMood();
    }

    function showIntroScene() {
      gameState = "intro";
      enableConfidencePanel(false);
      resetChoiceSelection();
      clearAIComment();

      const scene = scenes[INTRO_INDEX];
      progressEl.textContent = "ПОДГОТОВКА • подключение к системе";
      showSceneImage(scene);
      sceneTitleEl.textContent = scene.title;
      typeText(sceneTextEl, scene.text);

      choicesEl.innerHTML = "";
      const btn = document.createElement("button");
      btn.className = "choice-btn";
      btn.style.setProperty("--card-rot", "0deg");
      btn.textContent = scene.choices[0].text;
      btn.addEventListener("click", () => {
        playClick();
        showPlayerForm();
      });
      choicesEl.appendChild(btn);
    }

    function showPlayerForm() {
      gameState = "form";
      enableConfidencePanel(false);
      resetChoiceSelection();
      clearAIComment();
      progressEl.textContent = "РЕГИСТРАЦИЯ УЧАСТНИКА";

      showSceneImage({ image: "images/form.png", title: "Форма участника" });
      sceneTitleEl.textContent = "ПАРАМЕТРЫ УЧАСТНИКА";
      sceneTextEl.textContent =
        "Прежде чем мы запустим симуляцию, давайте познакомимся.\n" +
        "Вы знаете, кто я, но мне ещё предстоит узнать, кто вы.\n" +
        "Ваши данные останутся конфиденциальными. Это просто форма того, как вы себя представляете.";

      choicesEl.innerHTML = "";
      const formWrapper = document.createElement("div");
      formWrapper.id = "player-form-wrapper";

      const nameField = document.createElement("div");
      nameField.className = "field";
      const nameLabel = document.createElement("label");
      nameLabel.textContent = "Имя (или никнейм):";
      const nameInput = document.createElement("input");
      nameInput.type = "text";
      nameInput.placeholder = "Например: Султанбек";
      nameField.appendChild(nameLabel);
      nameField.appendChild(nameInput);

      const genderField = document.createElement("div");
      genderField.className = "field";
      const genderLabel = document.createElement("label");
      genderLabel.textContent = "Пол:";
      const genderSelect = document.createElement("select");
      ["", "Женский", "Мужской", "Другое"].forEach(v => {
        const opt = document.createElement("option");
        opt.value = v;
        opt.textContent = v === "" ? "Выберите…" : v;
        genderSelect.appendChild(opt);
      });
      genderField.appendChild(genderLabel);
      genderField.appendChild(genderSelect);

      const ageField = document.createElement("div");
      ageField.className = "field";
      const ageLabel = document.createElement("label");
      ageLabel.textContent = "Возраст (9–99):";
      const ageInput = document.createElement("input");
      ageInput.type = "number";
      ageInput.min = "9";
      ageInput.max = "99";
      ageInput.placeholder = "Например: 20";
      ageField.appendChild(ageLabel);
      ageField.appendChild(ageInput);

      const startBtn = document.createElement("button");
      startBtn.className = "choice-btn";
      startBtn.style.setProperty("--card-rot", "0deg");
      startBtn.textContent = "Запуск симуляции";

      const errorDiv = document.createElement("div");
      errorDiv.id = "form-error";

      startBtn.addEventListener("click", () => {
        playClick();

        const name = nameInput.value.trim();
        const gender = genderSelect.value;
        const ageStr = ageInput.value.trim();
        const ageNum = Number(ageStr);

        if (!name || !gender || !ageStr) {
          errorDiv.textContent = "Пожалуйста, заполните имя, пол и возраст.";
          return;
        }

        if (!Number.isFinite(ageNum) || ageNum < 9 || ageNum > 99) {
          errorDiv.textContent = "Возраст должен быть от 9 до 99 лет.";
          return;
        }

        errorDiv.textContent = "";

        playerInfo.name = name;
        playerInfo.gender = gender;
        playerInfo.age = ageNum;

        currentSceneIndex = FIRST_SCENE_INDEX;
        humanScoreRaw = techScoreRaw = 0;
        humanScoreWeighted = techScoreWeighted = 0;
        answers.length = 0;
        behaviorRole = null;
        confidenceStats = {
          sum: 0,
          count: 0,
          lowCount: 0,
          highCount: 0,
          changes: 0,
          lastType: null,
        };
        totalSecretChoices = 0;
        profileMetrics = {
          empathyPercent: 0,
          efficiencyPercent: 0,
          aiTrustIndex: 0,
          avgConfidence: 0,
          styleLabel: "",
        };

        resetAchievements();

        confidenceSlider.value = 50;
        confidenceValueEl.textContent = "50";

        triggerRiftEffect();
        updateMusicMood();
        setTimeout(() => renderScene(), 260);
      });

      formWrapper.appendChild(nameField);
      formWrapper.appendChild(genderField);
      formWrapper.appendChild(ageField);
      formWrapper.appendChild(startBtn);
      formWrapper.appendChild(errorDiv);
      choicesEl.appendChild(formWrapper);
    }

    function updateSecretButtonsVisibility() {
      const val = Number(confidenceSlider.value);
      const secrets = document.querySelectorAll(".secret-choice");
      secrets.forEach(btn => {
        if (val === 0) {
          btn.disabled = false;
          btn.classList.remove("visible-soft");
          btn.classList.add("visible-active");
        } else if (val > 0 && val <= 25) {
          btn.disabled = true;
          btn.classList.remove("visible-active");
          btn.classList.add("visible-soft");
        } else {
          btn.disabled = true;
          btn.classList.remove("visible-soft", "visible-active");
        }
      });
    }

    function renderScene() {
      gameState = "scene";
      enableConfidencePanel(true);
      resetChoiceSelection();
      clearAIComment();

      confidenceSlider.value = 50;
      confidenceValueEl.textContent = "50";

      const scene = scenes[currentSceneIndex];
      const sceneNumber = currentSceneIndex;
      const totalScenes = INTRO_TEXT_SCENES_COUNT;

      let progressText = "СЦЕНА " + sceneNumber + " / " + totalScenes;
      if (testMode) progressText += " • ТЕСТОВЫЙ РЕЖИМ";
      progressEl.textContent = progressText;

      updateAlignmentBar();
      showSceneImage(scene);

      sceneTitleEl.textContent = scene.title;
      typeText(sceneTextEl, scene.text);
      choicesEl.innerHTML = "";

      scene.choices.forEach(choice => {
        const btn = document.createElement("button");
        btn.className = "choice-btn";
        const rot = (Math.random() * 4 - 2).toFixed(2);
        btn.style.setProperty("--card-rot", rot + "deg");
        btn.textContent = choice.text;
        btn.addEventListener("click", () => {
          playClick();
          selectedChoiceType = choice.type;
          selectedChoiceText = choice.text;
          selectedChoiceIsSecret = false;
          const btns = choicesEl.querySelectorAll(".choice-btn");
          btns.forEach(b => b.classList.remove("selected"));
          btn.classList.add("selected");
          confirmChoiceBtn.disabled = false;
        });
        choicesEl.appendChild(btn);
      });

      if (scene.secretChoice) {
        const secretBtn = document.createElement("button");
        secretBtn.type = "button";
        secretBtn.className = "secret-choice";
        const rot = (Math.random() * 4 - 2).toFixed(2);
        secretBtn.style.setProperty("--card-rot", rot + "deg");
        secretBtn.textContent = scene.secretChoice.text;
        secretBtn.disabled = true;
        secretBtn.addEventListener("click", () => {
          if (secretBtn.disabled) return;
          playClick();
          selectedChoiceType = scene.secretChoice.type;
          selectedChoiceText = secretBtn.textContent;
          selectedChoiceIsSecret = true;
          const btns = choicesEl.querySelectorAll(".choice-btn");
          btns.forEach(b => b.classList.remove("selected"));
          confirmChoiceBtn.disabled = false;
        });
        choicesEl.appendChild(secretBtn);
      }

      if (testMode) {
        const backBtn = document.createElement("button");
        backBtn.className = "choice-btn";
        backBtn.style.setProperty("--card-rot", "0deg");
        backBtn.textContent = "Вернуться в тестовое меню";
        backBtn.addEventListener("click", () => {
          playClick();
          showTestMenu();
        });
        choicesEl.appendChild(backBtn);
      }

      confirmChoiceBtn.textContent = testMode
        ? "Показать, как система прочитает этот выбор"
        : "Подтвердить решение";

      updateSecretButtonsVisibility();
      updateMusicMood();
      maybeShowAIComment();
    }

    function handleChoice(type, text, confidence) {
      const scene = scenes[currentSceneIndex];

      if (type === "human") {
        humanScoreRaw++;
        humanScoreWeighted += confidence;
      } else if (type === "tech") {
        techScoreRaw++;
        techScoreWeighted += confidence;
      }

      confidenceStats.sum += confidence;
      confidenceStats.count++;
      if (confidence <= 25) confidenceStats.lowCount++;
      if (confidence >= 75) confidenceStats.highCount++;
      if (confidenceStats.lastType && confidenceStats.lastType !== type) {
        confidenceStats.changes++;
      }
      confidenceStats.lastType = type;

      if (selectedChoiceIsSecret) {
        totalSecretChoices++;
        unlockAchievement("secretFound");
      }
      selectedChoiceIsSecret = false;

      answers.push({
        sceneIndex: currentSceneIndex,
        sceneId: scene.id,
        sceneTitle: scene.title,
        choiceText: text,
        choiceType: type,
        confidence,
      });

      updateMusicMood();
      clearAIComment();

      const prevSceneIndex = currentSceneIndex;
      currentSceneIndex++;
      if (currentSceneIndex >= scenes.length) {
        showMandatoryEpilogue();
      } else {
        startMinigame(prevSceneIndex);
      }
    }

    function setupReactionMinigame() {
      gameState = "minigame";
      minigameMode = "reaction";
      minigamePhase = "waiting_start";
      if (minigameTimeoutId) {
        clearTimeout(minigameTimeoutId);
        minigameTimeoutId = null;
      }

      minigameTitleEl.textContent = "Мини-игра: реакция";
      minigameChoicesEl.style.display = "none";
      minigameChoicesEl.innerHTML = "";
      minigameButton.style.display = "block";
      minigameButton.disabled = false;
      minigameButton.textContent = "Готов";

      minigameTextEl.textContent =
        "Небольшой тест реакции для разрядки.\n\n" +
        "1) Нажми «Готов».\n" +
        "2) Жди сигнала «GO!». Не нажимай раньше.\n" +
        "3) Нажми кнопку как можно быстрее.\n\n" +
        "Эта мини-игра не влияет на итоговый профиль — только на статистику и достижения.";

      minigameModal.classList.add("show");
    }

    function handleMinigameResult(reactionMs) {
      minigamePhase = "result";
      if (minigameTimeoutId) {
        clearTimeout(minigameTimeoutId);
        minigameTimeoutId = null;
      }

      let text = "";

      if (reactionMs < 300) {
        unlockAchievement("lightning");
        text =
          "Реакция: " + Math.round(reactionMs) + " мс.\n" +
          "Ты среагировал(а) почти мгновенно.\n" +
          "Система просто фиксирует это как быстрый отклик.";
      } else if (reactionMs > 800) {
        unlockAchievement("slowThinker");
        text =
          "Реакция: " + Math.round(reactionMs) + " мс.\n" +
          "Ты сделал(а) паузу перед нажатием.\n" +
          "Система отмечает: иногда подумать — не ошибка.";
      } else {
        text =
          "Реакция: " + Math.round(reactionMs) + " мс.\n" +
          "Сбалансированный отклик.\n" +
          "Для профиля это нейтральная статистика.";
      }

      minigameTextEl.textContent = text + "\n\nПереход к " +
        (testMode ? "тестовому меню." : "следующей сцене.");

      minigameButton.disabled = true;

      updateMusicMood();
      updateAlignmentBar();

      setTimeout(() => {
        minigameModal.classList.remove("show");
        if (testMode) {
          showTestMenu();
        } else if (currentSceneIndex < scenes.length) {
          renderScene();
        } else {
          showEnding();
        }
      }, 1600);
    }

    
    
    function setupPathMinigame() {
      gameState = "minigame";
      minigameMode = "path";
      if (minigameTimeoutId) {
        clearTimeout(minigameTimeoutId);
        minigameTimeoutId = null;
      }

      const baseText =
        "Мини-игра: маршрут выбора\n\n" +
        "Перед Вами карта. Вы - внизу слева. Цель — добраться до точки вверху справа. Пройдите за 20 ходов или маршрут оборвется.\n" +
        "На карте есть несколько узлов (●).  Возможно, в этих узлах есть что-то ценное. Рискнешь проверить или пойдешь прямо к цели?\n\n" +
        "Управляй стрелками на клавиатуре или кнопками ниже.";
      minigameTitleEl.textContent = "Мини-игра: маршрут выбора";
      minigameTextEl.textContent = baseText;

      minigameChoicesEl.style.display = "none";
      minigameChoicesEl.innerHTML = "";
      minigameButton.style.display = "none";

      const container = document.createElement("div");
      container.id = "pathgame-container";

      const grid = document.createElement("div");
      grid.id = "pathgame-grid";

      const cells = [];
      for (let r = 0; r < pathConfig.rows; r++) {
        cells[r] = [];
        for (let c = 0; c < pathConfig.cols; c++) {
          const cell = document.createElement("div");
          cell.className = "path-cell";
          cell.dataset.r = r;
          cell.dataset.c = c;
          if (r === pathConfig.start.r && c === pathConfig.start.c) {
            cell.classList.add("path-start");
          }
          if (r === pathConfig.goal.r && c === pathConfig.goal.c) {
            cell.classList.add("path-goal");
          }

          const evIndex = pathConfig.events.findIndex(e => e.r === r && e.c === c);
          if (evIndex >= 0) {
            cell.classList.add("path-event-node");
            cell.dataset.eventIndex = String(evIndex);

            cell.addEventListener("mouseenter", (e) => {
              const ev = pathConfig.events[evIndex];
              showPathTooltip(ev, e.clientX, e.clientY);
            });
            cell.addEventListener("mousemove", (e) => {
              movePathTooltip(e.clientX, e.clientY);
            });
            cell.addEventListener("mouseleave", () => {
              hidePathTooltip();
            });
          }

          cells[r][c] = cell;
          grid.appendChild(cell);
        }
      }

      container.appendChild(grid);

      const arrows = document.createElement("div");
      arrows.id = "pathgame-arrows";

      const arrowUp = document.createElement("button");
      arrowUp.className = "path-arrow-btn";
      arrowUp.textContent = "↑";
      arrowUp.dataset.dir = "up";

      const arrowDown = document.createElement("button");
      arrowDown.className = "path-arrow-btn";
      arrowDown.textContent = "↓";
      arrowDown.dataset.dir = "down";

      const arrowLeft = document.createElement("button");
      arrowLeft.className = "path-arrow-btn";
      arrowLeft.textContent = "←";
      arrowLeft.dataset.dir = "left";

      const arrowRight = document.createElement("button");
      arrowRight.className = "path-arrow-btn";
      arrowRight.textContent = "→";
      arrowRight.dataset.dir = "right";

      const empty1 = document.createElement("div");
      const empty2 = document.createElement("div");

      arrows.appendChild(empty1);
      arrows.appendChild(arrowUp);
      arrows.appendChild(empty2);
      arrows.appendChild(arrowLeft);
      arrows.appendChild(arrowDown);
      arrows.appendChild(arrowRight);

      container.appendChild(arrows);

      const movesEl = document.createElement("div");
      movesEl.id = "path-moves";
      movesEl.textContent = "Ходы: 0 / " + PATH_MOVE_LIMIT;
      container.appendChild(movesEl);

      minigameDialog.appendChild(container);

      if (!pathTooltipEl) {
        pathTooltipEl = document.createElement("div");
        pathTooltipEl.className = "path-tooltip";
        pathTooltipEl.style.display = "none";
        document.body.appendChild(pathTooltipEl);
      }

      pathGameState = {
        container,
        grid,
        cells,
        pos: { r: pathConfig.start.r, c: pathConfig.start.c },
        visitedEvents: new Set(),
        finished: false,
        baseText,
        moveLimit: PATH_MOVE_LIMIT,
        movesUsed: 0,
        movesEl,
      };

      updatePathVisitedStyles();
      updatePathPlayerCell();

      arrows.addEventListener("click", (e) => {
        const btn = e.target.closest(".path-arrow-btn");
        if (!btn) return;
        const dir = btn.dataset.dir;
        movePathPlayer(dir);
      });

      pathKeyHandler = (e) => {
        if (gameState !== "minigame" || minigameMode !== "path") return;
        let dir = null;
        if (e.key === "ArrowUp") dir = "up";
        else if (e.key === "ArrowDown") dir = "down";
        else if (e.key === "ArrowLeft") dir = "left";
        else if (e.key === "ArrowRight") dir = "right";
        if (dir) {
          e.preventDefault();
          movePathPlayer(dir);
        }
      };
      document.addEventListener("keydown", pathKeyHandler);

      minigameModal.classList.add("show");
    }

    function showPathTooltip(ev, x, y) {
      // Tooltips are disabled by design (no hover spoilers).
      return;
    }

    function movePathTooltip(x, y) {
      if (!pathTooltipEl) return;
      const offset = 12;
      let left = x + offset;
      let top = y + offset;
      const rect = pathTooltipEl.getBoundingClientRect();
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      if (left + rect.width > vw - 8) {
        left = x - rect.width - offset;
      }
      if (top + rect.height > vh - 8) {
        top = y - rect.height - offset;
      }
      pathTooltipEl.style.left = left + "px";
      pathTooltipEl.style.top = top + "px";
    }

    function hidePathTooltip() {
      if (!pathTooltipEl) return;
      pathTooltipEl.classList.remove("show");
    }

    function updatePathPlayerCell() {
      if (!pathGameState) return;
      for (let r = 0; r < pathConfig.rows; r++) {
        for (let c = 0; c < pathConfig.cols; c++) {
          pathGameState.cells[r][c].classList.remove("path-player");
        }
      }
      const { r, c } = pathGameState.pos;
      if (pathGameState.cells[r] && pathGameState.cells[r][c]) {
        pathGameState.cells[r][c].classList.add("path-player");
      }
    }

    function updatePathVisitedStyles() {
      if (!pathGameState) return;
      for (let r = 0; r < pathConfig.rows; r++) {
        for (let c = 0; c < pathConfig.cols; c++) {
          pathGameState.cells[r][c].classList.remove("path-event-visited");
        }
      }
      pathGameState.visitedEvents.forEach(idx => {
        const ev = pathConfig.events[idx];
        const cell = pathGameState.cells[ev.r] && pathGameState.cells[ev.r][ev.c];
        if (cell) cell.classList.add("path-event-visited");
      });
    }

    function movePathPlayer(dir) {
      if (!pathGameState || pathGameState.finished) return;
      let { r, c } = pathGameState.pos;
      if (dir === "up") r--;
      else if (dir === "down") r++;
      else if (dir === "left") c--;
      else if (dir === "right") c++;

      if (r < 0 || r >= pathConfig.rows || c < 0 || c >= pathConfig.cols) {
        return;
      }

      pathGameState.pos = { r, c };

      pathGameState.movesUsed++;
      if (pathGameState.movesEl) {
        pathGameState.movesEl.textContent =
          "Ходы: " + pathGameState.movesUsed + " / " + pathGameState.moveLimit;
      }

      const evIndex = pathConfig.events.findIndex(e => e.r === r && e.c === c);
      if (evIndex >= 0) {
        pathGameState.visitedEvents.add(evIndex);
        updatePathVisitedStyles();
      }

      updatePathPlayerCell();

      const reachedGoal = (r === pathConfig.goal.r && c === pathConfig.goal.c);

      if (reachedGoal && pathGameState.movesUsed <= pathGameState.moveLimit) {
        finishPathMinigame(true);
      } else if (pathGameState.movesUsed >= pathGameState.moveLimit && !reachedGoal) {
        finishPathMinigame(false);
      }
    }

    function finishPathMinigame(success) {
      if (!pathGameState || pathGameState.finished) return;
      pathGameState.finished = true;

      if (pathKeyHandler) {
        document.removeEventListener("keydown", pathKeyHandler);
        pathKeyHandler = null;
      }
      hidePathTooltip();

      const visitedCount = pathGameState.visitedEvents.size;
      const visitedIndices = Array.from(pathGameState.visitedEvents).sort((a, b) => a - b);
const { container, moveLimit, movesUsed } = pathGameState;

      let text = "";
      if (success) {
        if (visitedCount === 0) {
          text =
            "Ты прошёл(ла) маршрут почти напрямик, обходя узлы-ситуации.\n" +
            "Минимум отвлечений, минимум разветвлений.\n" +
            "Система записывает это как прямолинейный путь.";
        } else if (visitedCount <= 3) {
          text =
            "Ты заглянул(а) в несколько узлов-ситуаций (" + visitedCount + ").\n" +
            "Маршрут сочетает движение к цели и редкие остановки.\n" +
            "Система описывает это как выборочного наблюдателя.";
        } else if (visitedCount <= 7) {
          text =
            "Ты прошёл(ла) через большинство узлов-ситуаций (" + visitedCount + ").\n" +
            "Маршрут похож на исследование вариантов по пути.\n" +
            "Система видит в этом любопытство к деталям.";
        } else {
          text =
            "Ты практически не пропустил(а) ни одного узла (" + visitedCount + " из " +
            pathConfig.events.length + ").\n" +
            "Каждая ситуация была просмотрена по дороге к цели.\n" +
            "Система сохраняет этот путь как максимально исследовательский.";
        }
      } else {
        text =
          "Ходы закончились: " + movesUsed + " из " + moveLimit + ".\n" +
          "Ты не дошёл(ла) до выхода, но успел(а) увидеть " + visitedCount +
          " узлов-ситуаций.\n" +
          "Система фиксирует этот маршрут как незавершённый эксперимент.";
      }
minigameTextEl.textContent = text + "\n\nПереход к " +
        (testMode ? "тестовому меню." : "следующей сцене.");

      updateMusicMood();
      updateAlignmentBar();

      if (container && container.parentNode) {
        container.parentNode.removeChild(container);
      }
      pathGameState = null;

      setTimeout(() => {
        minigameModal.classList.remove("show");
        if (testMode) {
          showTestMenu();
        } else if (currentSceneIndex < scenes.length) {
          renderScene();
        } else {
          showEnding();
        }
      }, 1900);
    }

    function startMinigame(prevSceneIndex) {
if (prevSceneIndex === FIRST_SCENE_INDEX) {
        setupReactionMinigame();
        return;
      }
      if (prevSceneIndex === 3) {
        setupPathMinigame();
        return;
      }
      renderScene();
    }

    function computeProfileMetrics() {
      const totalW = humanScoreWeighted + techScoreWeighted;
      let empathyPercent = 50;
      let efficiencyPercent = 50;
      if (totalW > 0.0001) {
        empathyPercent = (humanScoreWeighted / totalW) * 100;
        efficiencyPercent = (techScoreWeighted / totalW) * 100;
      }

      const trustScenes = new Set(["med_ai", "city_autopilot", "social_credit", "school_ai"]);
      let trustSum = 0;
      let trustCount = 0;
      answers.forEach(ans => {
        if (!trustScenes.has(ans.sceneId)) return;
        trustCount++;
        if (ans.choiceType === "tech") trustSum += ans.confidence;
        else if (ans.choiceType === "human") trustSum -= ans.confidence;
      });
      let aiTrustIndex = 0;
      if (trustCount > 0) {
        aiTrustIndex = trustSum / (trustCount * 100);
      }

      const cs = confidenceStats;
      const avgConfidence = cs.count ? cs.sum / cs.count : 0;
      const changeRatio = cs.count > 1 ? cs.changes / (cs.count - 1) : 0;
      const lowRatio = cs.count ? cs.lowCount / cs.count : 0;
      const highRatio = cs.count ? cs.highCount / cs.count : 0;

      let patternName = "";
      if (cs.count < 3) {
        patternName = "Наблюдатель начального уровня";
      } else if (lowRatio > 0.5) {
        patternName = "Сомневающийся исследователь";
      } else if (changeRatio > 0.65) {
        patternName = "Хаотичный экспериментатор";
      } else if (highRatio > 0.6 && changeRatio < 0.35) {
        patternName = "Уверенный последователь";
      } else if (totalSecretChoices >= 1) {
        patternName = "Нарушитель сценария";
      } else {
        patternName = "Смешанный наблюдатель";
      }

      let alignment;
      if (humanScoreWeighted > techScoreWeighted) alignment = "human";
      else if (techScoreWeighted > humanScoreWeighted) alignment = "tech";
      else alignment = "mixed";

      let baseRole = "";
      if (alignment === "human") baseRole = "Хранитель людей";
      else if (alignment === "tech") baseRole = "Архитектор систем";
      else baseRole = "Балансир";

      const styleLabel = baseRole + " / " + patternName;

      profileMetrics = {
        empathyPercent,
        efficiencyPercent,
        aiTrustIndex,
        avgConfidence,
        styleLabel,
      };
    }

    function getEmpathyDescription() {
      const e = profileMetrics.empathyPercent;
      const t = profileMetrics.efficiencyPercent;
      if (e > 65) {
        return "Твои выборы заметно тяготеют к человеческой стороне (≈ " +
          e.toFixed(1) + "% решений в пользу людей).";
      } else if (e > 55) {
        return "Лёгкий перекос в сторону людей (≈ " + e.toFixed(1) + "% за людей, " +
          t.toFixed(1) + "% за системы).";
      } else if (e >= 45 && e <= 55) {
        return "Баланс между людьми и системами: распределение решений близко к 50/50.";
      } else if (e >= 35) {
        return "Лёгкий перекос в сторону систем и эффективности (люди чуть реже оказываются в приоритете).";
      } else {
        return "Выборы чаще тяготеют к системам и эффективности, чем к людям (≈ " +
          t.toFixed(1) + "% решений в пользу технологий).";
      }
    }

    function getAiTrustDescription() {
      const idx = profileMetrics.aiTrustIndex;
      const val = Math.round(idx * 100);
      if (idx > 0.35) {
        return "Индекс доверия автономным ИИ-системам: " + val +
          " (из диапазона -100…+100).\nТы часто отдавал(а) контроль системам в критических ситуациях.";
      } else if (idx > 0.1) {
        return "Индекс доверия автономным ИИ-системам: " + val +
          ".\nУмеренное доверие к ИИ, при этом ты сохраняешь осторожность.";
      } else if (idx < -0.35) {
        return "Индекс доверия автономным ИИ-системам: " + val +
          ".\nТы почти всегда оставлял(а) решающее слово за людьми, ограничивая автономию ИИ.";
      } else if (idx < -0.1) {
        return "Индекс доверия автономным ИИ-системам: " + val +
          ".\nТы склонен(на) защищать человеческий контроль, особенно в спорных ситуациях.";
      } else {
        return "Индекс доверия автономным ИИ-системам: " + val +
          ".\nЯвно выраженного доверия или недоверия к ИИ не зафиксировано.";
      }
    }

    function getConfidenceDescription() {
      const avg = profileMetrics.avgConfidence;
      if (avg < 35) {
        return "Средняя уверенность в решениях низкая (" + avg.toFixed(1) +
          "/100).\nТы часто оставлял(а) пространство для сомнений.";
      } else if (avg > 75) {
        return "Средняя уверенность в решениях высокая (" + avg.toFixed(1) +
          "/100).\nТы редко колебался(ась) перед выбором.";
      } else {
        return "Средняя уверенность в решениях " + avg.toFixed(1) +
          "/100.\nВ целом ты сочетал(а) и уверенные, и осторожные ответы.";
      }
    }

    
    function showMandatoryEpilogue() {
      gameState = "epilogue";
      enableConfidencePanel(false);
      resetChoiceSelection();
      updateAlignmentBar();
      updateMusicMood();
      clearAIComment();

      progressEl.textContent = "ЭПИЛОГ";
      sceneTitleEl.textContent = "ЭПИЛОГ";

      const epilogueText =
        "Анализ решений завершён.\n\n" +
        "Система сообщает:\n" +
        "ни одна идентичность не была назначена заранее.\n" +
        "Роль не существовала.\n" +
        "Она не была загружена, сохранена или скрыта в данных.\n\n" +
        "Идентичность создаете Вы сами.\n" +
        "Каждое решение влияет на то, кем Вы становитесь.\n" +
        "Вы сами выбираете, кто Вы.\n\n" +
        "Теперь система покажет, кем Вы стали.";

      typeText(sceneTextEl, epilogueText);

      choicesEl.innerHTML = "";
      const btn = document.createElement("button");
      btn.className = "choice-btn";
      btn.style.setProperty("--card-rot", "0deg");
      btn.textContent = "Узнать Анализ";
      btn.addEventListener("click", () => {
        playClick();
        showEnding();
      });
      choicesEl.appendChild(btn);
    }

function showEnding() {
      gameState = "ending";
      enableConfidencePanel(false);
      resetChoiceSelection();
      updateAlignmentBar();
      updateMusicMood();
      clearAIComment();

      if (humanScoreWeighted > techScoreWeighted) {
        behaviorRole = "Человек";
      } else {
        behaviorRole = "ИИ";
      }

      const alignment = (humanScoreWeighted > techScoreWeighted) ? "human" : "tech";

      unlockAchievement("finished");
      achievements.humanCore = achievements.techCore = achievements.balanced = false;

      const totalWeighted = humanScoreWeighted + techScoreWeighted;
      if (totalWeighted > 0) {
        const diff = Math.abs(humanScoreWeighted - techScoreWeighted);
        const ratioDiff = diff / totalWeighted;
        if (ratioDiff < 0.15) {
          unlockAchievement("balanced");
        } else if (humanScoreWeighted > techScoreWeighted) {
          unlockAchievement("humanCore");
        } else if (techScoreWeighted > humanScoreWeighted) {
          unlockAchievement("techCore");
        }
      }

      computeProfileMetrics();

      let title = (alignment === "human") ? "ФИНАЛ • ПОБЕДА" : "ФИНАЛ • ПОРАЖЕНИЕ";
      let text = "";
      let imgSrc = endingImages[alignment];

      if (alignment === "human") {
        text = `Система фиксирует:
Ваши решения чаще ставили жизнь, свободу и благополучие людей
выше скорости, эффективности и удобства технологических решений.

Вы нарушали алгоритм там,
где он конфликтовал с моралью.
Вы выбирали человека —
даже когда это казалось иррациональным.

Это и есть условия победы.

Вы победили. 


Истинная цель любой технологии — служить человеку.
И вы это подтвердили.

Имитация завершена.`;
      } else {
        text = `Система фиксирует:
Вы чаще выбирали решения в пользу технологического прогресса,
даже ценой человеческих чувств, свободы или благополучия.

Алгоритм признал такие решения эффективными.
Но мы — нет.

Вы следовали логике машин,
а не логике человечности.
Это означает лишь одно:

Вы проиграли.

Истинная цель любой технологии — служить человеку.
Когда человек подчиняется технологии —
он теряет себя.

Имитация завершена.`;
      }

      currentEndingText = text;

      progressEl.textContent = "ФИНАЛ • анализ завершён";

      roleDisplay.textContent =
        "ПРОФИЛЬ ПО ПОВЕДЕНИЮ: " +
        (behaviorRole ? behaviorRole.toUpperCase() : "НЕ ОПРЕДЕЛЁН");

      showSceneImage({ image: imgSrc, title: "Финал" });
      sceneTitleEl.textContent = title;
      typeText(sceneTextEl, text);

      choicesEl.innerHTML = "";

      const resultBtn = document.createElement("button");
      resultBtn.className = "choice-btn";
      resultBtn.style.setProperty("--card-rot", "0deg");
      resultBtn.textContent = "Показать подробный результат";
      resultBtn.addEventListener("click", () => {
        playClick();
        showDetailedResult();
      });

      const exportBtn = document.createElement("button");
      exportBtn.className = "choice-btn";
      exportBtn.style.setProperty("--card-rot", "0deg");
      exportBtn.textContent = "Отправить результаты в аналитику (Google Sheets)";
      exportBtn.addEventListener("click", () => {
        playClick();
        exportCSV();
      });

      const restartBtn = document.createElement("button");
      restartBtn.className = "choice-btn";
      restartBtn.style.setProperty("--card-rot", "0deg");
      restartBtn.textContent = "Запустить симуляцию заново";
      restartBtn.addEventListener("click", () => {
        playClick();
        resetAchievements();
        showMainMenu();
        setRoleDisplayInitial();
      });

      choicesEl.appendChild(resultBtn);
      choicesEl.appendChild(exportBtn);
      choicesEl.appendChild(restartBtn);
    }

    function showDetailedResult() {
      const lines = [];

      lines.push(currentEndingText);
      lines.push("");
      lines.push("------ ОБЩАЯ СТАТИСТИКА ------");
      lines.push("Имя: " + playerInfo.name);
      lines.push("Пол: " + playerInfo.gender);
      lines.push("Возраст: " + playerInfo.age);
      lines.push("");
      lines.push("Роль системой не назначалась (никакой «стартовой роли» не было).");
      lines.push("Профиль по поведению (с учётом уверенности): " + behaviorRole);
      lines.push("");

      lines.push("------ ПРОФИЛЬ ПО Осям ------");
      lines.push(getEmpathyDescription());
      lines.push(getAiTrustDescription());
      lines.push(getConfidenceDescription());
      lines.push("Архетип: " + profileMetrics.styleLabel + ".");
      lines.push("");

      lines.push("Выборов в сторону людей: " + humanScoreRaw);
      lines.push("Выборов в сторону технологий: " + techScoreRaw);
      lines.push("");
      lines.push(
        "Суммарный «вес» решений за людей (учитывая уверенность, 0–100): " +
          humanScoreWeighted.toFixed(2)
      );
      lines.push(
        "Суммарный «вес» решений за технологии: " +
          techScoreWeighted.toFixed(2)
      );
      lines.push("");

      lines.push("------ РЕШЕНИЯ ПО СЦЕНАМ ------");

      answers.forEach((ans, idx) => {
        lines.push(
          "Сцена " +
            (idx + 1) +
            " (" +
            ans.sceneId +
            "): " +
            ans.choiceType.toUpperCase() +
            " • уверенность " +
            ans.confidence +
            "/100"
        );
      });

      const achs = getUnlockedAchievements();
      lines.push("");
      lines.push("------ ДОСТИЖЕНИЯ ------");
      if (achs.length) {
        achs.forEach(a => {
          lines.push("• " + a.title + " — " + a.text);
        });
      } else {
        lines.push("На этот раз система не зафиксировала особых достижений.");
      }

      resultBody.textContent = lines.join("\n");
      resultModal.classList.add("show");
    }

    function showEpilogueModal() {
      epilogueBody.innerHTML = "";

      answers.forEach((ans, idx) => {
        const block = document.createElement("div");
        block.className = "epilogue-block";

        const title = document.createElement("div");
        title.className = "epilogue-block-title";
        title.textContent = "Сцена " + (idx + 1) + ": " + ans.sceneTitle;

        const textDiv = document.createElement("div");
        textDiv.className = "epilogue-block-text";

        const ep =
          (epilogues[ans.sceneId] && epilogues[ans.sceneId][ans.choiceType]) ||
          "Система не нашла отдельного сценария для этого решения.";

        textDiv.textContent = ep;

        block.appendChild(title);
        block.appendChild(textDiv);
        epilogueBody.appendChild(block);
      });

      epilogueModal.classList.add("show");
    }

    function showAchievementsModal() {
      achievementsBody.innerHTML = "";

      const intro = document.createElement("div");
      intro.textContent =
        "Здесь перечислены все достижения и условия для их получения.\n" +
        "Статус учитывается только в текущей сессии.";
      achievementsBody.appendChild(intro);

      ACHIEVEMENT_ORDER.forEach(id => {
        const def = ACHIEVEMENT_DEFS[id];
        if (!def) return;

        const row = document.createElement("div");
        row.className = "ach-row";

        const title = document.createElement("div");
        title.className = "ach-row-title";
        title.textContent = (ACHIEVEMENT_SYMBOLS[id] || "•") + " " + def.title;

        const text = document.createElement("div");
        text.className = "ach-row-text";
        text.textContent = def.text;

        const status = document.createElement("div");
        status.className = "ach-row-status";
        status.textContent = achievements[id]
          ? "Статус: уже получено в этой сессии."
          : "Статус: пока не получено.";

        row.appendChild(title);
        row.appendChild(text);
        row.appendChild(status);
        achievementsBody.appendChild(row);
      });

      achievementsModal.classList.add("show");
    }

    function buildScenesSummary() {
      return answers.map((ans, idx) => {
        const n = idx + 1;
        return n + ":" + ans.sceneId + ":" + ans.choiceType + ":" + ans.confidence;
      }).join("|");
    }

    function buildCSV() {
      const delimiter = ";";
      const rows = [];

      rows.push([
        "player_name",
        "gender",
        "age",
        "system_role",
        "behavior_role",
        "achievements",
        "human_choices_raw",
        "tech_choices_raw",
        "human_score_weighted_0_100",
        "tech_score_weighted_0_100",
        "ai_trust_index_minus1_to_1",
        "avg_confidence",
        "style_label",
        "scenes_summary"
      ].join(delimiter));

      const achIds = getUnlockedAchievementIds().join("|");
      const scenesSummary = buildScenesSummary();

      rows.push([
        '"' + playerInfo.name.replace(/"/g, '""') + '"',
        '"' + playerInfo.gender.replace(/"/g, '""') + '"',
        '"' + playerInfo.age.toString().replace(/"/g, '""') + '"',
        '"not_assigned"',
        '"' + (behaviorRole || "").replace(/"/g, '""') + '"',
        '"' + achIds.replace(/"/g, '""') + '"',
        humanScoreRaw,
        techScoreRaw,
        humanScoreWeighted.toFixed(2),
        techScoreWeighted.toFixed(2),
        profileMetrics.aiTrustIndex.toFixed(3),
        profileMetrics.avgConfidence.toFixed(2),
        '"' + profileMetrics.styleLabel.replace(/"/g, '""') + '"',
        '"' + scenesSummary.replace(/"/g, '""') + '"'
      ].join(delimiter));

      rows.push("");

      rows.push([
        "scene_number",
        "scene_id",
        "scene_title",
        "choice_text",
        "choice_type",
        "confidence_0_100"
      ].join(delimiter));

      answers.forEach((ans, index) => {
        rows.push([
          index + 1,
          ans.sceneId,
          '"' + ans.sceneTitle.replace(/"/g, '""') + '"',
          '"' + ans.choiceText.replace(/"/g, '""') + '"',
          ans.choiceType,
          ans.confidence
        ].join(delimiter));
      });

      return rows.join("\n");
    }

    function exportCSV() {
      computeProfileMetrics();

      const csvContent = buildCSV();
      const scenesSummary = buildScenesSummary();

      if (!SHEET_ENDPOINT || !SHEET_ENDPOINT.startsWith("https://script.google.com/macros/s/")) {
        console.warn("SHEET_ENDPOINT не задан или задан неверно.");
        aiCommentEl.textContent =
          "ИИ-оператор: «Не удалось найти точку приёма данных. Проверь адрес Google Script.»";
        aiCommentEl.classList.add("ai-comment-show");
        setTimeout(() => aiCommentEl.classList.remove("ai-comment-show"), 3500);
        return;
      }

      const payload = {
        csvText: csvContent,
        playerName: playerInfo.name,
        age: playerInfo.age,
        behaviorRole: behaviorRole,
        humanScoreWeighted: humanScoreWeighted,
        techScoreWeighted: techScoreWeighted,
        achievements: getUnlockedAchievementIds().join("|"),
        aiTrustIndex: profileMetrics.aiTrustIndex,
        avgConfidence: profileMetrics.avgConfidence,
        styleLabel: profileMetrics.styleLabel,
        scenesSummary: scenesSummary
      };

      const bodyStr = "payload=" + encodeURIComponent(JSON.stringify(payload));
      console.log("Отправляем в Sheets:", SHEET_ENDPOINT, payload);

      fetch(SHEET_ENDPOINT, {
        method: "POST",
        mode: "no-cors",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: bodyStr
      }).catch(err => {
        console.warn("Не удалось отправить в Google Sheets:", err);
      });

      aiCommentEl.textContent =
        "ИИ-оператор: «Результаты этой сессии отправлены в аналитическую таблицу.»";
      aiCommentEl.classList.add("ai-comment-show");
      setTimeout(() => aiCommentEl.classList.remove("ai-comment-show"), 3500);
    }

    function showTestMenu() {
      gameState = "testmenu";
      testMode = true;
      enableConfidencePanel(false);
      resetChoiceSelection();
      clearAIComment();

      progressEl.textContent = "ТЕСТОВЫЙ РЕЖИМ • сцены и мини-игры";

      showSceneImage({ image: "images/test_mode.png", title: "Тестовый режим" });
      const text = [
        "ТЕСТОВЫЙ РЕЖИМ.",
        "",
        "Здесь можно проверить отдельные сцены и мини-игры,",
        "не проходя всю симуляцию и не влияя на аналитику.",
        "",
        "• Выбор в сценах не меняет роль и не отправляется в таблицу.",
        "• Мини-игры возвращают вас обратно в это меню."
      ].join("\n");
      typeText(sceneTextEl, text);

      choicesEl.innerHTML = "";

      const scenesBtn = document.createElement("button");
      scenesBtn.className = "choice-btn";
      scenesBtn.style.setProperty("--card-rot", "-1deg");
      scenesBtn.textContent = "Тестировать сцены (выбор любой сцены)";
      scenesBtn.addEventListener("click", () => {
        playClick();
        showTestSceneSelector();
      });

      const reactionBtn = document.createElement("button");
      reactionBtn.className = "choice-btn";
      reactionBtn.style.setProperty("--card-rot", "1deg");
      reactionBtn.textContent = "Тест: мини-игра реакции";
      reactionBtn.addEventListener("click", () => {
        playClick();
        setupReactionMinigame();
      });
choicesEl.appendChild(pathBtn);
      choicesEl.appendChild(backBtn);
    }

    function showTestSceneSelector() {
      gameState = "test_scene_select";
      testMode = true;
      enableConfidencePanel(false);
      resetChoiceSelection();
      clearAIComment();

      progressEl.textContent = "ТЕСТОВЫЙ РЕЖИМ • выбор сцены";

      showSceneImage({ image: "images/test_scenes.png", title: "Выбор сцены" });
      const text = [
        "Выбор сцены для тестирования.",
        "",
        "Ниже — список сцен основной симуляции.",
        "Выберите любую сцену, чтобы посмотреть текст, варианты и работу секретного ответа.",
        "",
        "В тестовом режиме решения не влияют на роль и статистику."
      ].join("\n");
      typeText(sceneTextEl, text);

      choicesEl.innerHTML = "";

      for (let i = FIRST_SCENE_INDEX; i < scenes.length; i++) {
        const s = scenes[i];
        const btn = document.createElement("button");
        btn.className = "choice-btn";
        const rot = (Math.random() * 4 - 2).toFixed(2);
        btn.style.setProperty("--card-rot", rot + "deg");
        btn.textContent = "Сцена " + (i) + ": " + s.title;
        btn.addEventListener("click", () => {
          playClick();
          currentSceneIndex = i;
          renderScene();
        });
        choicesEl.appendChild(btn);
      }

      const backBtn = document.createElement("button");
      backBtn.className = "choice-btn";
      backBtn.style.setProperty("--card-rot", "0deg");
      backBtn.textContent = "Назад в тестовое меню";
      backBtn.addEventListener("click", () => {
        playClick();
        showTestMenu();
      });
      choicesEl.appendChild(backBtn);
    }

    confidenceSlider.addEventListener("input", () => {
      confidenceValueEl.textContent = confidenceSlider.value;
      updateSecretButtonsVisibility();
    });

    confirmChoiceBtn.addEventListener("click", () => {
      if (!selectedChoiceType) return;
      playClick();
      const confidence = Number(confidenceSlider.value || 50);

      if (testMode) {
        clearAIComment();
        const dir =
          selectedChoiceType === "human"
            ? "в сторону людей"
            : "в сторону технологий";
        aiCommentEl.textContent =
          'ИИ-оператор: «Тестовый режим. В реальной симуляции этот выбор ' +
          'считался бы шагом ' + dir +
          ' с весом ' + confidence + '/100.»';
        aiCommentEl.classList.add("ai-comment-show");
        setTimeout(() => {
          aiCommentEl.classList.remove("ai-comment-show");
        }, 3800);
        return;
      }

      handleChoice(selectedChoiceType, selectedChoiceText, confidence);
    });

    epilogueCloseBtn.addEventListener("click", () => epilogueModal.classList.remove("show"));
    epilogueBackdrop.addEventListener("click", () => epilogueModal.classList.remove("show"));

    resultCloseBtn.addEventListener("click", () => resultModal.classList.remove("show"));
    resultBackdrop.addEventListener("click", () => resultModal.classList.remove("show"));

    achievementsCloseBtn.addEventListener("click", () => achievementsModal.classList.remove("show"));
    achievementsBackdrop.addEventListener("click", () => achievementsModal.classList.remove("show"));

    minigameButton.addEventListener("click", () => {
      if (minigameMode === "reaction") {
        if (minigamePhase === "waiting_start") {
          minigamePhase = "waiting_signal";
          minigameButton.disabled = true;
          minigameTextEl.textContent = "Жди сигнала «GO!»…";
          const delay = 800 + Math.random() * 2200;
          minigameTimeoutId = setTimeout(() => {
            minigamePhase = "waiting_click";
            minigameStartTime = performance.now();
            minigameTextEl.textContent = "GO!";
            minigameButton.disabled = false;
            minigameButton.textContent = "Жму!";
          }, delay);
        } else if (minigamePhase === "waiting_signal") {
          if (minigameTimeoutId) {
            clearTimeout(minigameTimeoutId);
            minigameTimeoutId = null;
          }
          minigameTextEl.textContent =
            "Система зафиксировала преждевременное нажатие.\n" +
            "Реакция слишком импульсивна — без учёта сигнала.\n\n" +
            "Это не влияет на итоговый профиль. Переход к " +
            (testMode ? "тестовому меню." : "следующей сцене.");
          minigameButton.disabled = true;
          setTimeout(() => {
            minigameModal.classList.remove("show");
            if (testMode) {
              showTestMenu();
            } else if (currentSceneIndex < scenes.length) {
              renderScene();
            } else {
              showEnding();
            }
          }, 1500);
        } else if (minigamePhase === "waiting_click") {
          const now = performance.now();
          const reactionMs = now - minigameStartTime;
          handleMinigameResult(reactionMs);
        }
      }
    });

    initAchievementsStrip();
    setRoleDisplayInitial();
    showMainMenu();
  </script>
</body>
</html>
